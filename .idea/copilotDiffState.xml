<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.jetbrains.kotlin.android)&#10;    alias(libs.plugins.compose.compiler)&#10;    alias(libs.plugins.ksp.gradle.plugin)&#10;    id(&quot;com.google.dagger.hilt.android&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.working_timer&quot;&#10;    compileSdk = 34&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.working_timer&quot;&#10;        minSdk = 26&#10;        targetSdk = 34&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;), &quot;proguard-rules.pro&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;1.8&quot;&#10;    }&#10;    buildFeatures {&#10;        viewBinding = true&#10;        compose = true&#10;    }&#10;&#10;}&#10;&#10;dependencies {&#10;    implementation(libs.lifecycle.runtime.ktx)&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    annotationProcessor(libs.room.compiler)&#10;    ksp(libs.room.compiler)&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;&#10;    implementation(&quot;androidx.compose.ui:ui:1.5.3&quot;)&#10;    implementation(&quot;androidx.compose.material3:material3:1.2.1&quot;)&#10;    implementation(&quot;androidx.activity:activity-compose:1.7.2&quot;)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.3&quot;)&#10;    implementation(&quot;com.google.android.material:material:1.10.0&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.8.0&quot;)&#10;&#10;    implementation(&quot;com.google.dagger:hilt-android:2.56.2&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.2.0&quot;)&#10;    ksp(&quot;com.google.dagger:hilt-android-compiler:2.56.2&quot;)&#10;&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.6&quot;)&#10;&#10;    implementation(&quot;androidx.lifecycle:lifecycle-service:2.6.2&quot;)&#10;&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.1.7&quot;)&#10;}" />
              <option name="updatedContent" value="plugins {&#13;&#10;    alias(libs.plugins.android.application)&#13;&#10;    alias(libs.plugins.jetbrains.kotlin.android)&#13;&#10;    alias(libs.plugins.compose.compiler)&#13;&#10;    alias(libs.plugins.ksp.gradle.plugin)&#13;&#10;    id(&quot;com.google.dagger.hilt.android&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;android {&#13;&#10;    namespace = &quot;com.example.working_timer&quot;&#13;&#10;    compileSdk = 34&#13;&#10;&#13;&#10;    defaultConfig {&#13;&#10;        applicationId = &quot;com.example.working_timer&quot;&#13;&#10;        minSdk = 26&#13;&#10;        targetSdk = 34&#13;&#10;        versionCode = 1&#13;&#10;        versionName = &quot;1.0&quot;&#13;&#10;&#13;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    buildTypes {&#13;&#10;        release {&#13;&#10;            isMinifyEnabled = false&#13;&#10;            proguardFiles(getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;), &quot;proguard-rules.pro&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    compileOptions {&#13;&#10;        sourceCompatibility = JavaVersion.VERSION_1_8&#13;&#10;        targetCompatibility = JavaVersion.VERSION_1_8&#13;&#10;    }&#13;&#10;    kotlinOptions {&#13;&#10;        jvmTarget = &quot;1.8&quot;&#13;&#10;    }&#13;&#10;    buildFeatures {&#13;&#10;        viewBinding = true&#13;&#10;        compose = true&#13;&#10;    }&#13;&#10;&#13;&#10;}&#13;&#10;&#13;&#10;dependencies {&#13;&#10;    implementation(libs.lifecycle.runtime.ktx)&#13;&#10;    implementation(libs.room.runtime)&#13;&#10;    implementation(libs.room.ktx)&#13;&#10;    annotationProcessor(libs.room.compiler)&#13;&#10;    ksp(libs.room.compiler)&#13;&#10;&#13;&#10;    implementation(libs.androidx.core.ktx)&#13;&#10;    implementation(libs.androidx.appcompat)&#13;&#10;    implementation(libs.material)&#13;&#10;    implementation(libs.androidx.activity)&#13;&#10;    implementation(libs.androidx.constraintlayout)&#13;&#10;    testImplementation(libs.junit)&#13;&#10;    androidTestImplementation(libs.androidx.junit)&#13;&#10;    androidTestImplementation(libs.androidx.espresso.core)&#13;&#10;&#13;&#10;    implementation(&quot;androidx.compose.ui:ui:1.5.3&quot;)&#13;&#10;    implementation(&quot;androidx.compose.material3:material3:1.2.1&quot;)&#13;&#10;    implementation(&quot;androidx.activity:activity-compose:1.7.2&quot;)&#13;&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.3&quot;)&#13;&#10;    implementation(&quot;androidx.compose.ui:ui-tooling-preview:1.5.3&quot;)&#13;&#10;    debugImplementation(&quot;androidx.compose.ui:ui-tooling:1.5.3&quot;)&#13;&#10;    implementation(&quot;com.google.android.material:material:1.10.0&quot;)&#13;&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.8.0&quot;)&#13;&#10;&#13;&#10;    implementation(&quot;com.google.dagger:hilt-android:2.56.2&quot;)&#13;&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.2.0&quot;)&#13;&#10;    ksp(&quot;com.google.dagger:hilt-android-compiler:2.56.2&quot;)&#13;&#10;&#13;&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.6&quot;)&#13;&#10;&#13;&#10;    implementation(&quot;androidx.lifecycle:lifecycle-service:2.6.2&quot;)&#13;&#10;&#13;&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.1.7&quot;)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkScreen.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.app.Activity&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.withStyle&#10;import androidx.compose.ui.text.SpanStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.working_timer.ui.components.DatePickerModal&#10;import com.example.working_timer.ui.components.MaterialTimePickerDialog&#10;import com.example.working_timer.R&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EditWorkScreen(&#10;    editWorkViewModel: EditWorkViewModel = hiltViewModel(),&#10;    id: Int,&#10;    startDay: String,&#10;    isNew: Boolean,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showStartTimePicker by remember { mutableStateOf(false) }&#10;    var showStartDayPicker by remember { mutableStateOf(false) }&#10;    var showEndTimePicker by remember { mutableStateOf(false) }&#10;    var showEndDayPicker by remember { mutableStateOf(false) }&#10;&#10;    var showElapsedPicker by remember { mutableStateOf(false) }&#10;&#10;    val uiState by editWorkViewModel.uiState.collectAsState()&#10;&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // 初期値を設定する&#10;        editWorkViewModel.init(id, isNew, startDay)&#10;&#10;        // イベントを監視する&#10;        editWorkViewModel.uiEvent.collectLatest { event -&gt;&#10;            when (event) {&#10;                is EditWorkViewModel.UiEvent.ShowSnackbar -&gt; {&#10;                    scope.launch {&#10;                        snackbarHostState.showSnackbar(event.message)&#10;                    }&#10;                }&#10;                EditWorkViewModel.UiEvent.SaveSuccess -&gt; { onNavigateBack() }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },&#10;        modifier = modifier&#10;    ) { _ -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            val context = LocalContext.current&#10;            Text(&#10;                text = context.getString(if (isNew) R.string.new_record else R.string.edit_record),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp),&#10;            )&#10;&#10;            Spacer(modifier = Modifier.weight(0.3f))&#10;&#10;            Text(&quot;開始&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showStartDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.startDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showStartTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.startTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;終了&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showEndDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.endDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showEndTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.endTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;活動時間&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showElapsedPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            if (uiState.elapsedHour &gt; 0) {&#10;                                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                    append(String.format(&quot;%2d&quot;, uiState.elapsedHour))&#10;                                }&#10;                                append(&quot; 時間 &quot;)&#10;                            }&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(String.format(&quot;%2d&quot;, uiState.elapsedMinute))&#10;                            }&#10;                            append(&quot; 分&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(0.2f))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Button(&#10;                    onClick = {&#10;                        onNavigateBack()&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;キャンセル&quot;)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(24.dp))&#10;&#10;                Button(&#10;                    onClick = {&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        editWorkViewModel.saveWork(&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            id = id,&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            isNew = isNew,&#10;                            forceSave = false&#10;                        )&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;保存&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        if (showStartTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.startTime),&#10;                onDismiss = { showStartTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateStartTime(it)&#10;                    showStartTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showEndTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.endTime),&#10;                onDismiss = { showEndTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateEndTime(it)&#10;                    showEndTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showStartDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.startDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateStartDay(it)&#10;                    showStartDayPicker = false&#10;                },&#10;                onDismiss = { showStartDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showEndDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.endDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateEndDay(it)&#10;                    showEndDayPicker = false&#10;                },&#10;                onDismiss = { showEndDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showElapsedPicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = Pair(uiState.elapsedHour, uiState.elapsedMinute),&#10;                onDismiss = { showElapsedPicker = false },&#10;                onTimeSelected = { timeString -&gt;&#10;                    val (h, m) = timeString.split(&quot;:&quot;).map { it.toIntOrNull() ?: 0 }&#10;                    editWorkViewModel.updateElapsedTime(h, m)&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                    showElapsedPicker = false&#10;                },&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                showToggleIcon = false&#10;            )&#10;        }&#10;&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;        if (uiState.showZeroMinutesError) {&#10;            AlertDialog(&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                onDismissRequest = { editWorkViewModel.clearZeroMinutesError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;1分以上からのみ記録が可能です。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearZeroMinutesError() }) {&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;        }&#10;&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;        if (uiState.showStartEndError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearStartEndError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                text = { Text(&quot;開始時刻が終了時刻を超えています。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearStartEndError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                }&#10;            )&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;        }&#10;&#10;        if (uiState.showElapsedTimeOver) {&#10;            AlertDialog(&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                onDismissRequest = { editWorkViewModel.clearElapsedTimeOver() },&#10;                title = { Text(&quot;注意&quot;) },&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                text = { Text(&quot;活動時間が時間差より大きいです。\nこのまま保存しますか？&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        editWorkViewModel.clearElapsedTimeOver()&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            isNew = isNew,&#10;                            forceSave = true&#10;                        )&#10;                    }) {&#10;                        Text(&quot;保存&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;&#10;&#10;&#10;                    TextButton(onClick = { editWorkViewModel.clearElapsedTimeOver() }) {&#10;                        Text(&quot;キャンセル&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun parseTime(time: String): Pair&lt;Int, Int&gt; {&#10;    val parts = time.split(&quot;:&quot;).mapNotNull { it.toIntOrNull() }&#10;    return if (parts.size == 2) Pair(parts[0], parts[1]) else Pair(0, 0)&#10;&#10;&#10;&#10;}&#10;&#10;fun formatMonthDay(fullDate: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;M/d&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(fullDate)&#10;        outputFormat.format(date)&#10;    } catch (e: Exception) {&#10;        fullDate&#10;    }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.app.Activity&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.withStyle&#10;import androidx.compose.ui.text.SpanStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.working_timer.ui.components.DatePickerModal&#10;import com.example.working_timer.ui.components.MaterialTimePickerDialog&#10;import com.example.working_timer.R&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EditWorkScreen(&#10;    editWorkViewModel: EditWorkViewModel = hiltViewModel(),&#10;    id: Int,&#10;    startDay: String,&#10;    isNew: Boolean,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showStartTimePicker by remember { mutableStateOf(false) }&#10;    var showStartDayPicker by remember { mutableStateOf(false) }&#10;    var showEndTimePicker by remember { mutableStateOf(false) }&#10;    var showEndDayPicker by remember { mutableStateOf(false) }&#10;&#10;    var showElapsedPicker by remember { mutableStateOf(false) }&#10;&#10;    val uiState by editWorkViewModel.uiState.collectAsState()&#10;&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // 初期値を設定する&#10;        editWorkViewModel.init(id, isNew, startDay)&#10;&#10;        // イベントを監視する&#10;        editWorkViewModel.uiEvent.collectLatest { event -&gt;&#10;            when (event) {&#10;                is EditWorkViewModel.UiEvent.ShowSnackbar -&gt; {&#10;                    scope.launch {&#10;                        snackbarHostState.showSnackbar(event.message)&#10;                    }&#10;                }&#10;                EditWorkViewModel.UiEvent.SaveSuccess -&gt; { onNavigateBack() }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },&#10;        modifier = modifier&#10;    ) { _ -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            val context = LocalContext.current&#10;            Text(&#10;                text = context.getString(if (isNew) R.string.new_record else R.string.edit_record),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp),&#10;            )&#10;&#10;            Spacer(modifier = Modifier.weight(0.3f))&#10;&#10;            Text(&quot;開始&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showStartDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.startDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showStartTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.startTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;終了&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showEndDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.endDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showEndTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.endTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;活動時間&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showElapsedPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            if (uiState.elapsedHour &gt; 0) {&#10;                                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                    append(String.format(&quot;%2d&quot;, uiState.elapsedHour))&#10;                                }&#10;                                append(&quot; 時間 &quot;)&#10;                            }&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(String.format(&quot;%2d&quot;, uiState.elapsedMinute))&#10;                            }&#10;                            append(&quot; 分&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(0.2f))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Button(&#10;                    onClick = {&#10;                        onNavigateBack()&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;キャンセル&quot;)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(24.dp))&#10;&#10;                Button(&#10;                    onClick = {&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            isNew = isNew,&#10;                            forceSave = false&#10;                        )&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;保存&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        if (showStartTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.startTime),&#10;                onDismiss = { showStartTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateStartTime(it)&#10;                    showStartTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showEndTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.endTime),&#10;                onDismiss = { showEndTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateEndTime(it)&#10;                    showEndTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showStartDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.startDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateStartDay(it)&#10;                    showStartDayPicker = false&#10;                },&#10;                onDismiss = { showStartDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showEndDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.endDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateEndDay(it)&#10;                    showEndDayPicker = false&#10;                },&#10;                onDismiss = { showEndDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showElapsedPicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = Pair(uiState.elapsedHour, uiState.elapsedMinute),&#10;                onDismiss = { showElapsedPicker = false },&#10;                onTimeSelected = { timeString -&gt;&#10;                    val (h, m) = timeString.split(&quot;:&quot;).map { it.toIntOrNull() ?: 0 }&#10;                    editWorkViewModel.updateElapsedTime(h, m)&#10;                    showElapsedPicker = false&#10;                },&#10;                showToggleIcon = false&#10;            )&#10;        }&#10;&#10;        if (uiState.showZeroMinutesError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearZeroMinutesError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;1分以上からのみ記録が可能です。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearZeroMinutesError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showStartEndError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearStartEndError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;開始時刻が終了時刻を超えています。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearStartEndError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showElapsedTimeOver) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearElapsedTimeOver() },&#10;                title = { Text(&quot;注意&quot;) },&#10;                text = { Text(&quot;活動時間が時間差より大きいです。\nこのまま保存しますか？&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        editWorkViewModel.clearElapsedTimeOver()&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            isNew = isNew,&#10;                            forceSave = true&#10;                        )&#10;                    }) {&#10;                        Text(&quot;保存&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearElapsedTimeOver() }) {&#10;                        Text(&quot;キャンセル&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun parseTime(time: String): Pair&lt;Int, Int&gt; {&#10;    val parts = time.split(&quot;:&quot;).mapNotNull { it.toIntOrNull() }&#10;    return if (parts.size == 2) Pair(parts[0], parts[1]) else Pair(0, 0)&#10;}&#10;&#10;fun formatMonthDay(fullDate: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;M/d&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(fullDate)&#10;        outputFormat.format(date)&#10;    } catch (e: Exception) {&#10;        fullDate&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/main/MainScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/main/MainScreen.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.main&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.DialogProperties&#10;import androidx.core.content.ContextCompat&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.working_timer.ui.components.FooterNavigationBar&#10;import com.example.working_timer.util.PauseButtonColor&#10;import com.example.working_timer.util.ResumeButtonColor&#10;import com.example.working_timer.util.StartButtonColor&#10;import com.example.working_timer.util.StatusDefaultColor&#10;import com.example.working_timer.util.StatusPauseColor&#10;import com.example.working_timer.util.StatusWorkingColor&#10;import com.example.working_timer.util.StopButtonColor&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun MainScreenHolder(&#10;    mainViewModel: MainViewModel = hiltViewModel(),&#10;    onNavigateToLog: () -&gt; Unit&#10;) {&#10;    val uiState by mainViewModel.uiState.collectAsState()&#10;&#10;    val context = LocalContext.current&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // ViewModelからのsnackbarMessage監視&#10;    LaunchedEffect(uiState.snackbarMessage) {&#10;        uiState.snackbarMessage?.let { message -&gt;&#10;            snackbarHostState.showSnackbar(message)&#10;            mainViewModel.clearSnackbarMessage()&#10;        }&#10;    }&#10;&#10;    // ナビゲーション処理はステートフルで管理&#10;    LaunchedEffect(uiState.navigateToLog) {&#10;        if (uiState.navigateToLog) {&#10;            onNavigateToLog()&#10;            mainViewModel.onNavigationHandled()&#10;        }&#10;    }&#10;&#10;    // 通知権限が許可されているか確認&#10;    val isNotificationGranted = remember(context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.POST_NOTIFICATIONS&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        } else {&#10;            true // Android 12以前は通知権限が不要&#10;        }&#10;    }&#10;&#10;    // 通知権限ランチャー&#10;    val requestPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        scope.launch {&#10;            val message = if (isGranted) {&#10;                &quot;通知が許可されました。&quot;&#10;            } else {&#10;                &quot;通知が拒否されました。&quot;&#10;            }&#10;            snackbarHostState.showSnackbar(message)&#10;        }&#10;    }&#10;&#10;    MainScreen(&#10;        uiState = uiState,&#10;        snackbarHostState = snackbarHostState,&#10;        onNavigateToLog = onNavigateToLog,&#10;        onStartTimer = {&#10;            mainViewModel.startTimer()&#10;            if (!isNotificationGranted) {&#10;                scope.launch {&#10;                    snackbarHostState.showSnackbar(&quot;通知をONにすると、タイマーの進行状況が確認できます。&quot;)&#10;                }&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                    requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        },&#10;        onStopTimer = { mainViewModel.stopTimer() },&#10;        onPauseTimer = { mainViewModel.pauseTimer() },&#10;        onResumeTimer = { mainViewModel.resumeTimer() },&#10;        onDiscardWork = { mainViewModel.discardWork() },&#10;        onSaveWork = { mainViewModel.saveWork() },&#10;        onDismissSaveDialog = { mainViewModel.dismissSaveDialog() }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    uiState: TimerUiState,&#10;    snackbarHostState: SnackbarHostState,&#10;    onNavigateToLog: () -&gt; Unit,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onPauseTimer: () -&gt; Unit,&#10;    onResumeTimer: () -&gt; Unit,&#10;    onDiscardWork: () -&gt; Unit,&#10;    onSaveWork: () -&gt; Unit,&#10;    onDismissSaveDialog: () -&gt; Unit&#10;) {&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(snackbarHostState) },&#10;        bottomBar = {&#10;            FooterNavigationBar(&#10;                selectedIndex = 0,&#10;                onTimerClick = {},&#10;                onLogClick = onNavigateToLog&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues),&#10;            verticalArrangement = Arrangement.Center,&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Spacer(Modifier.weight(1f))&#10;&#10;            Text(&#10;                text = uiState.status,&#10;                textAlign = TextAlign.Center,&#10;                fontSize = 48.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = when (uiState.status) {&#10;                    &quot;労働中&quot; -&gt; StatusWorkingColor&#10;                    &quot;休憩中&quot; -&gt; StatusPauseColor&#10;                    else -&gt; StatusDefaultColor&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            Text(&#10;                text = uiState.timerText,&#10;                textAlign = TextAlign.Center,&#10;                fontSize = 56.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.weight(1f))&#10;&#10;            // 開始ボタン&#10;            if (!uiState.isTimerRunning &amp;&amp; !uiState.isPaused) {&#10;                Button(&#10;                    onClick = onStartTimer,&#10;                    modifier = Modifier.size(100.dp),&#10;                    shape = RoundedCornerShape(40.dp),&#10;                    colors = ButtonDefaults.buttonColors(containerColor = StartButtonColor)&#10;                ) {&#10;                    Text(&quot;開始&quot;, fontSize = 20.sp, color = Color.White)&#10;                }&#10;            }&#10;&#10;            // 終了、休憩ボタン&#10;            if (uiState.isTimerRunning) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center&#10;                ) {&#10;                    Spacer(Modifier.weight(1f))&#10;&#10;                    Button(&#10;                        onClick = onStopTimer,&#10;                        modifier = Modifier.size(100.dp),&#10;                        shape = RoundedCornerShape(40.dp),&#10;                        colors = ButtonDefaults.buttonColors(containerColor = StopButtonColor)&#10;                    ) {&#10;                        Text(&quot;終了&quot;, fontSize = 20.sp, color = Color.White)&#10;                    }&#10;&#10;                    Spacer(Modifier.weight(1f))&#10;&#10;                    Button(&#10;                        onClick = onPauseTimer,&#10;                        modifier = Modifier.size(100.dp),&#10;                        shape = RoundedCornerShape(40.dp),&#10;                        colors = ButtonDefaults.buttonColors(containerColor = PauseButtonColor)&#10;                    ) {&#10;                        Text(&quot;休憩&quot;, fontSize = 20.sp, color = Color.White)&#10;                    }&#10;&#10;                    Spacer(Modifier.weight(1f))&#10;                }&#10;            }&#10;&#10;            // 再開ボタン&#10;            if (uiState.isPaused) {&#10;                Button(&#10;                    onClick = onResumeTimer,&#10;                    modifier = Modifier.size(100.dp),&#10;                    shape = RoundedCornerShape(40.dp),&#10;                    colors = ButtonDefaults.buttonColors(containerColor = ResumeButtonColor)&#10;                ) {&#10;                    Text(&quot;再開&quot;, fontSize = 20.sp, color = Color.White)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f))&#10;        }&#10;&#10;        // 保存確認ダイアログ&#10;        if (uiState.showSaveDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = onDismissSaveDialog,&#10;                title = { Text(&quot;確認&quot;) },&#10;                text = { Text(&#10;                    uiState.dialogMessage,&#10;                    fontWeight = FontWeight.Medium&#10;                ) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    // ダイアログのメッセージによってボタンの挙動を変える&#10;                    if (uiState.isErrorDialog) {&#10;                        Row {&#10;                            TextButton(onClick = {&#10;                                onDiscardWork()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;破棄&quot;)&#10;                            }&#10;                            TextButton(onClick = {&#10;                                onResumeTimer()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;再開&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Row {&#10;                            TextButton(onClick = {&#10;                                onDiscardWork()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;破棄&quot;)&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.width(64.dp))&#10;&#10;                            TextButton(onClick = {&#10;                                onResumeTimer()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;再開&quot;)&#10;                            }&#10;                            TextButton(onClick = onSaveWork) {&#10;                                Text(&quot;保存&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.working_timer.ui.main&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.DialogProperties&#10;import androidx.core.content.ContextCompat&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.example.working_timer.ui.components.FooterNavigationBar&#10;import com.example.working_timer.util.PauseButtonColor&#10;import com.example.working_timer.util.ResumeButtonColor&#10;import com.example.working_timer.util.StartButtonColor&#10;import com.example.working_timer.util.StatusDefaultColor&#10;import com.example.working_timer.util.StatusPauseColor&#10;import com.example.working_timer.util.StatusWorkingColor&#10;import com.example.working_timer.util.StopButtonColor&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun MainScreenHolder(&#10;    mainViewModel: MainViewModel = hiltViewModel(),&#10;    onNavigateToLog: () -&gt; Unit&#10;) {&#10;    val uiState by mainViewModel.uiState.collectAsState()&#10;&#10;    val context = LocalContext.current&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // ViewModelからのsnackbarMessage監視&#10;    LaunchedEffect(uiState.snackbarMessage) {&#10;        uiState.snackbarMessage?.let { message -&gt;&#10;            snackbarHostState.showSnackbar(message)&#10;            mainViewModel.clearSnackbarMessage()&#10;        }&#10;    }&#10;&#10;    // ナビゲーション処理はステートフルで管理&#10;    LaunchedEffect(uiState.navigateToLog) {&#10;        if (uiState.navigateToLog) {&#10;            onNavigateToLog()&#10;            mainViewModel.onNavigationHandled()&#10;        }&#10;    }&#10;&#10;    // 通知権限が許可されているか確認&#10;    val isNotificationGranted = remember(context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.POST_NOTIFICATIONS&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        } else {&#10;            true // Android 12以前は通知権限が不要&#10;        }&#10;    }&#10;&#10;    // 通知権限ランチャー&#10;    val requestPermissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        scope.launch {&#10;            val message = if (isGranted) {&#10;                &quot;通知が許可されました。&quot;&#10;            } else {&#10;                &quot;通知が拒否されました。&quot;&#10;            }&#10;            snackbarHostState.showSnackbar(message)&#10;        }&#10;    }&#10;&#10;    MainScreen(&#10;        uiState = uiState,&#10;        snackbarHostState = snackbarHostState,&#10;        onNavigateToLog = onNavigateToLog,&#10;        onStartTimer = {&#10;            mainViewModel.startTimer()&#10;            if (!isNotificationGranted) {&#10;                scope.launch {&#10;                    snackbarHostState.showSnackbar(&quot;通知をONにすると、タイマーの進行状況が確認できます。&quot;)&#10;                }&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                    requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        },&#10;        onStopTimer = { mainViewModel.stopTimer() },&#10;        onPauseTimer = { mainViewModel.pauseTimer() },&#10;        onResumeTimer = { mainViewModel.resumeTimer() },&#10;        onDiscardWork = { mainViewModel.discardWork() },&#10;        onSaveWork = { mainViewModel.saveWork() },&#10;        onDismissSaveDialog = { mainViewModel.dismissSaveDialog() }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    uiState: TimerUiState,&#10;    snackbarHostState: SnackbarHostState,&#10;    onNavigateToLog: () -&gt; Unit,&#10;    onStartTimer: () -&gt; Unit,&#10;    onStopTimer: () -&gt; Unit,&#10;    onPauseTimer: () -&gt; Unit,&#10;    onResumeTimer: () -&gt; Unit,&#10;    onDiscardWork: () -&gt; Unit,&#10;    onSaveWork: () -&gt; Unit,&#10;    onDismissSaveDialog: () -&gt; Unit&#10;) {&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(snackbarHostState) },&#10;        bottomBar = {&#10;            FooterNavigationBar(&#10;                selectedIndex = 0,&#10;                onTimerClick = {},&#10;                onLogClick = onNavigateToLog&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues),&#10;            verticalArrangement = Arrangement.Center,&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Spacer(Modifier.weight(1f))&#10;&#10;            Text(&#10;                text = uiState.status,&#10;                textAlign = TextAlign.Center,&#10;                fontSize = 48.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = when (uiState.status) {&#10;                    &quot;労働中&quot; -&gt; StatusWorkingColor&#10;                    &quot;休憩中&quot; -&gt; StatusPauseColor&#10;                    else -&gt; StatusDefaultColor&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            Text(&#10;                text = uiState.timerText,&#10;                textAlign = TextAlign.Center,&#10;                fontSize = 56.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(Modifier.weight(1f))&#10;&#10;            // 開始ボタン&#10;            if (!uiState.isTimerRunning &amp;&amp; !uiState.isPaused) {&#10;                Button(&#10;                    onClick = onStartTimer,&#10;                    modifier = Modifier.size(100.dp),&#10;                    shape = RoundedCornerShape(40.dp),&#10;                    colors = ButtonDefaults.buttonColors(containerColor = StartButtonColor)&#10;                ) {&#10;                    Text(&quot;開始&quot;, fontSize = 20.sp, color = Color.White)&#10;                }&#10;            }&#10;&#10;            // 終了、休憩ボタン&#10;            if (uiState.isTimerRunning) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center&#10;                ) {&#10;                    Spacer(Modifier.weight(1f))&#10;&#10;                    Button(&#10;                        onClick = onStopTimer,&#10;                        modifier = Modifier.size(100.dp),&#10;                        shape = RoundedCornerShape(40.dp),&#10;                        colors = ButtonDefaults.buttonColors(containerColor = StopButtonColor)&#10;                    ) {&#10;                        Text(&quot;終了&quot;, fontSize = 20.sp, color = Color.White)&#10;                    }&#10;&#10;                    Spacer(Modifier.weight(1f))&#10;&#10;                    Button(&#10;                        onClick = onPauseTimer,&#10;                        modifier = Modifier.size(100.dp),&#10;                        shape = RoundedCornerShape(40.dp),&#10;                        colors = ButtonDefaults.buttonColors(containerColor = PauseButtonColor)&#10;                    ) {&#10;                        Text(&quot;休憩&quot;, fontSize = 20.sp, color = Color.White)&#10;                    }&#10;&#10;                    Spacer(Modifier.weight(1f))&#10;                }&#10;            }&#10;&#10;            // 再開ボタン&#10;            if (uiState.isPaused) {&#10;                Button(&#10;                    onClick = onResumeTimer,&#10;                    modifier = Modifier.size(100.dp),&#10;                    shape = RoundedCornerShape(40.dp),&#10;                    colors = ButtonDefaults.buttonColors(containerColor = ResumeButtonColor)&#10;                ) {&#10;                    Text(&quot;再開&quot;, fontSize = 20.sp, color = Color.White)&#10;                }&#10;            }&#10;&#10;            Spacer(Modifier.weight(1f))&#10;        }&#10;&#10;        // 保存確認ダイアログ&#10;        if (uiState.showSaveDialog) {&#10;            AlertDialog(&#10;                onDismissRequest = onDismissSaveDialog,&#10;                title = { Text(&quot;確認&quot;) },&#10;                text = { Text(&#10;                    uiState.dialogMessage,&#10;                    fontWeight = FontWeight.Medium&#10;                ) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    // ダイアログのメッセージによってボタンの挙動を変える&#10;                    if (uiState.isErrorDialog) {&#10;                        Row {&#10;                            TextButton(onClick = {&#10;                                onDiscardWork()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;破棄&quot;)&#10;                            }&#10;                            TextButton(onClick = {&#10;                                onResumeTimer()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;再開&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Row {&#10;                            TextButton(onClick = {&#10;                                onDiscardWork()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;破棄&quot;)&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.width(64.dp))&#10;&#10;                            TextButton(onClick = {&#10;                                onResumeTimer()&#10;                                onDismissSaveDialog()&#10;                            }) {&#10;                                Text(&quot;再開&quot;)&#10;                            }&#10;                            TextButton(onClick = onSaveWork) {&#10;                                Text(&quot;保存&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// Preview for MainScreen (stateless)&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun MainScreenPreview() {&#10;    val sampleState = TimerUiState(&#10;        status = &quot;労働中&quot;,&#10;        timerText = &quot;01:23:45&quot;,&#10;        isTimerRunning = true,&#10;        isPaused = false,&#10;        elapsedTime = 5025000L,&#10;        showSaveDialog = true,&#10;        dialogMessage = &quot;&quot;&quot;&#10;            開始日 ： 2025-09-02&#10;            経過時間 ： 1時間 23分&#10;+&#10;+            今回の作業記録を保存しますか？&#10;+        &quot;&quot;&quot;.trimIndent(),&#10;        isErrorDialog = false&#10;    )&#10;&#10;    MainScreen(&#10;        uiState = sampleState,&#10;        snackbarHostState = remember { SnackbarHostState() },&#10;        onNavigateToLog = {},&#10;        onStartTimer = {},&#10;        onStopTimer = {},&#10;        onPauseTimer = {},&#10;        onResumeTimer = {},&#10;        onDiscardWork = {},&#10;        onSaveWork = {},&#10;        onDismissSaveDialog = {}&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>