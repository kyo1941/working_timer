<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/example/working_timer/data/repository/WorkRepositoryImplTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/example/working_timer/data/repository/WorkRepositoryImplTest.kt" />
              <option name="originalContent" value="package com.example.working_timer.data.repository&#10;&#10;import com.example.working_timer.data.db.Work&#10;import com.example.working_timer.data.db.WorkDao&#10;import io.mockk.coEvery&#10;import io.mockk.coVerify&#10;import io.mockk.every&#10;import io.mockk.mockk&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.test.runTest&#10;import org.junit.Before&#10;import org.junit.Test&#10;import org.junit.Assert.*&#10;&#10;class WorkRepositoryImplTest {&#10;&#10;    private lateinit var workDao: WorkDao&#10;    private lateinit var workRepository: WorkRepositoryImpl&#10;&#10;    private val testWork = Work(&#10;        id = 1,&#10;        start_day = &quot;2025-01-04&quot;,&#10;        end_day = &quot;2025-01-04&quot;,&#10;        start_time = &quot;09:00&quot;,&#10;        end_time = &quot;17:00&quot;,&#10;        elapsed_time = 480&#10;    )&#10;&#10;    private val testWorkList = listOf(&#10;        testWork,&#10;        Work(&#10;            start_day = &quot;2025-01-04&quot;,&#10;            end_day = &quot;2025-01-04&quot;,&#10;            start_time = &quot;18:00&quot;,&#10;            end_time = &quot;20:00&quot;,&#10;            elapsed_time = 120&#10;        )&#10;    )&#10;&#10;    @Before&#10;    fun setup() {&#10;        workDao = mockk()&#10;        workRepository = WorkRepositoryImpl(workDao)&#10;    }&#10;&#10;    @Test&#10;    fun `getWork returns flow of work from dao`() = runTest {&#10;        // Given&#10;        val workId = 1&#10;        val workFlow = flowOf(testWork)&#10;        every { workDao.getWork(workId) } returns workFlow&#10;&#10;        // When&#10;        val result = workRepository.getWork(workId)&#10;&#10;        // Then&#10;        assertEquals(workFlow, result)&#10;        io.mockk.verify { workDao.getWork(workId) }&#10;    }&#10;&#10;    @Test&#10;    fun `getWorksByDay returns list of works from dao`() = runTest {&#10;        // Given&#10;        val day = &quot;2025-01-04&quot;&#10;        coEvery { workDao.getWorksByDay(day) } returns testWorkList&#10;&#10;        // When&#10;        val result = workRepository.getWorksByDay(day)&#10;&#10;        // Then&#10;        assertEquals(testWorkList, result)&#10;        coVerify { workDao.getWorksByDay(day) }&#10;    }&#10;&#10;    @Test&#10;    fun `getWorksByDay returns empty list when no works found`() = runTest {&#10;        // Given&#10;        val day = &quot;2025-01-05&quot;&#10;        val emptyList = emptyList&lt;Work&gt;()&#10;        coEvery { workDao.getWorksByDay(day) } returns emptyList&#10;&#10;        // When&#10;        val result = workRepository.getWorksByDay(day)&#10;&#10;        // Then&#10;        assertEquals(emptyList, result)&#10;        coVerify { workDao.getWorksByDay(day) }&#10;    }&#10;&#10;    @Test&#10;    fun `insert calls dao insert with correct work`() = runTest {&#10;        // Given&#10;        coEvery { workDao.insert(testWork) } returns Unit&#10;&#10;        // When&#10;        workRepository.insert(testWork)&#10;&#10;        // Then&#10;        coVerify { workDao.insert(testWork) }&#10;    }&#10;&#10;    @Test&#10;    fun `delete calls dao delete with correct id`() = runTest {&#10;        // Given&#10;        val workId = 1&#10;        coEvery { workDao.delete(workId) } returns Unit&#10;&#10;        // When&#10;        workRepository.delete(workId)&#10;&#10;        // Then&#10;        coVerify { workDao.delete(workId) }&#10;    }&#10;&#10;    @Test&#10;    fun `update calls dao update with correct work`() = runTest {&#10;        // Given&#10;        val updatedWork = testWork.copy(elapsed_time = 500)&#10;        coEvery { workDao.update(updatedWork) } returns Unit&#10;&#10;        // When&#10;        workRepository.update(updatedWork)&#10;&#10;        // Then&#10;        coVerify { workDao.update(updatedWork) }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.working_timer.data.repository&#10;&#10;import com.example.working_timer.data.db.Work&#10;import com.example.working_timer.data.db.WorkDao&#10;import io.mockk.coEvery&#10;import io.mockk.coVerify&#10;import io.mockk.every&#10;import io.mockk.mockk&#10;import io.mockk.verify&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.ExperimentalCoroutinesApi&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.test.StandardTestDispatcher&#10;import kotlinx.coroutines.test.advanceUntilIdle&#10;import kotlinx.coroutines.test.runTest&#10;import kotlinx.coroutines.test.setMain&#10;import kotlinx.coroutines.test.resetMain&#10;import org.junit.After&#10;import org.junit.Before&#10;import org.junit.Test&#10;import org.junit.Assert.*&#10;&#10;@OptIn(ExperimentalCoroutinesApi::class)&#10;class WorkRepositoryImplTest {&#10;&#10;    // テストケース独自の定数&#10;    companion object {&#10;        private const val TEST_WORK_ID = 1&#10;        private const val TEST_START_DAY = &quot;2025-01-04&quot;&#10;        private const val TEST_END_DAY = &quot;2025-01-04&quot;&#10;        private const val TEST_START_TIME = &quot;09:00&quot;&#10;        private const val TEST_END_TIME = &quot;17:00&quot;&#10;        private const val TEST_ELAPSED_TIME = 480&#10;        private const val TEST_DAY = &quot;2025-01-04&quot;&#10;        private const val UPDATED_ELAPSED_TIME = 500&#10;    }&#10;&#10;    private val testDispatcher = StandardTestDispatcher()&#10;    private lateinit var mockWorkDao: WorkDao&#10;    private lateinit var workRepository: WorkRepositoryImpl&#10;&#10;    // テスト用のデフォルトワーク&#10;    private val defaultTestWork = createTestWork()&#10;    private val defaultTestWorkList = listOf(&#10;        defaultTestWork,&#10;        createTestWork(&#10;            id = 2,&#10;            startTime = &quot;18:00&quot;,&#10;            endTime = &quot;20:00&quot;,&#10;            elapsedTime = 120&#10;        )&#10;    )&#10;&#10;    @Before&#10;    fun setup() {&#10;        Dispatchers.setMain(testDispatcher)&#10;        mockWorkDao = mockk(relaxed = true)&#10;        workRepository = WorkRepositoryImpl(mockWorkDao)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        Dispatchers.resetMain()&#10;    }&#10;&#10;    // 共通セットアップメソッド群&#10;    private fun setupMockWorkFlow(work: Work = defaultTestWork) {&#10;        val workFlow = flowOf(work)&#10;        every { mockWorkDao.getWork(work.id) } returns workFlow&#10;    }&#10;&#10;    private fun setupMockWorksByDay(works: List&lt;Work&gt; = defaultTestWorkList, day: String = TEST_DAY) {&#10;        coEvery { mockWorkDao.getWorksByDay(day) } returns works&#10;    }&#10;&#10;    private fun setupEmptyWorksByDay(day: String = TEST_DAY) {&#10;        setupMockWorksByDay(emptyList(), day)&#10;    }&#10;&#10;    private fun setupInsertScenario(work: Work = defaultTestWork) {&#10;        coEvery { mockWorkDao.insert(work) } returns Unit&#10;    }&#10;&#10;    private fun setupDeleteScenario(workId: Int = TEST_WORK_ID) {&#10;        coEvery { mockWorkDao.delete(workId) } returns Unit&#10;    }&#10;&#10;    private fun setupUpdateScenario(work: Work) {&#10;        coEvery { mockWorkDao.update(work) } returns Unit&#10;    }&#10;&#10;    @Test&#10;    fun `getWork実行時にDaoからWorkのFlowが返される`() = runTest {&#10;        // Given&#10;        setupMockWorkFlow()&#10;&#10;        // When&#10;        val result = workRepository.getWork(TEST_WORK_ID)&#10;&#10;        // Then&#10;        val resultWork = result.first()&#10;        assertEquals(defaultTestWork, resultWork)&#10;        verify { mockWorkDao.getWork(TEST_WORK_ID) }&#10;    }&#10;&#10;    @Test&#10;    fun `getWorksByDay実行時に指定した日のWorkリストが返される`() = runTest {&#10;        // Given&#10;        setupMockWorksByDay()&#10;&#10;        // When&#10;        val result = workRepository.getWorksByDay(TEST_DAY)&#10;&#10;        // Then&#10;        assertEquals(defaultTestWorkList, result)&#10;        assertEquals(2, result.size)&#10;        coVerify { mockWorkDao.getWorksByDay(TEST_DAY) }&#10;    }&#10;&#10;    @Test&#10;    fun `getWorksByDay実行時にWorkが見つからない場合は空のリストが返される`() = runTest {&#10;        // Given&#10;        val emptyDay = &quot;2025-01-05&quot;&#10;        setupEmptyWorksByDay(emptyDay)&#10;&#10;        // When&#10;        val result = workRepository.getWorksByDay(emptyDay)&#10;&#10;        // Then&#10;        assertTrue(result.isEmpty())&#10;        coVerify { mockWorkDao.getWorksByDay(emptyDay) }&#10;    }&#10;&#10;    @Test&#10;    fun `insert実行時に正しいWorkでDaoのinsertが呼ばれる`() = runTest {&#10;        // Given&#10;        setupInsertScenario()&#10;&#10;        // When&#10;        workRepository.insert(defaultTestWork)&#10;        advanceUntilIdle()&#10;&#10;        // Then&#10;        coVerify { mockWorkDao.insert(defaultTestWork) }&#10;    }&#10;&#10;    @Test&#10;    fun `delete実行時に正しいIDでDaoのdeleteが呼ばれる`() = runTest {&#10;        // Given&#10;        setupDeleteScenario()&#10;&#10;        // When&#10;        workRepository.delete(TEST_WORK_ID)&#10;        advanceUntilIdle()&#10;&#10;        // Then&#10;        coVerify { mockWorkDao.delete(TEST_WORK_ID) }&#10;    }&#10;&#10;    @Test&#10;    fun `update実行時に正しいWorkでDaoのupdateが呼ばれる`() = runTest {&#10;        // Given&#10;        val updatedWork = defaultTestWork.copy(elapsed_time = UPDATED_ELAPSED_TIME)&#10;        setupUpdateScenario(updatedWork)&#10;&#10;        // When&#10;        workRepository.update(updatedWork)&#10;        advanceUntilIdle()&#10;&#10;        // Then&#10;        coVerify { mockWorkDao.update(updatedWork) }&#10;    }&#10;&#10;    @Test&#10;    fun `複数のWorkに対してgetWorksByDayが正しく動作する`() = runTest {&#10;        // Given&#10;        val multipleWorks = listOf(&#10;            createTestWork(id = 1, elapsedTime = 240),&#10;            createTestWork(id = 2, elapsedTime = 360),&#10;            createTestWork(id = 3, elapsedTime = 180)&#10;        )&#10;        setupMockWorksByDay(multipleWorks)&#10;&#10;        // When&#10;        val result = workRepository.getWorksByDay(TEST_DAY)&#10;&#10;        // Then&#10;        assertEquals(3, result.size)&#10;        assertEquals(240, result[0].elapsed_time)&#10;        assertEquals(360, result[1].elapsed_time)&#10;        assertEquals(180, result[2].elapsed_time)&#10;        coVerify { mockWorkDao.getWorksByDay(TEST_DAY) }&#10;    }&#10;&#10;    @Test&#10;    fun `異なるIDのWorkに対してgetWorkが正しく動作する`() = runTest {&#10;        // Given&#10;        val differentWork = createTestWork(id = 999, startTime = &quot;10:00&quot;)&#10;        setupMockWorkFlow(differentWork)&#10;&#10;        // When&#10;        val result = workRepository.getWork(999)&#10;&#10;        // Then&#10;        val resultWork = result.first()&#10;        assertEquals(999, resultWork.id)&#10;        assertEquals(&quot;10:00&quot;, resultWork.start_time)&#10;        verify { mockWorkDao.getWork(999) }&#10;    }&#10;&#10;    private fun createTestWork(&#10;        id: Int = TEST_WORK_ID,&#10;        startDay: String = TEST_START_DAY,&#10;        endDay: String = TEST_END_DAY,&#10;        startTime: String = TEST_START_TIME,&#10;        endTime: String = TEST_END_TIME,&#10;        elapsedTime: Int = TEST_ELAPSED_TIME&#10;    ): Work {&#10;        return Work(&#10;            id = id,&#10;            start_day = startDay,&#10;            end_day = endDay,&#10;            start_time = startTime,&#10;            end_time = endTime,&#10;            elapsed_time = elapsedTime&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>