<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/data/db/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/data/db/AppDatabase.kt" />
              <option name="originalContent" value="package com.example.working_timer.data.db&#10;&#10;import androidx.room.Database&#10;import androidx.room.RoomDatabase&#10;&#10;@Database(entities = [Work::class], version = 5, exportSchema = false)    // バージョンを5に変更&#10;abstract class AppDatabase : RoomDatabase() {&#10;    abstract fun workDao(): WorkDao&#10;}" />
              <option name="updatedContent" value="package com.example.working_timer.data.db&#10;&#10;import androidx.room.Database&#10;import androidx.room.RoomDatabase&#10;&#10;@Database(entities = [Work::class], version = 5, exportSchema = false)    // バージョンを5に変更&#10;abstract class AppDatabase : RoomDatabase() {&#10;    abstract fun workDao(): WorkDao&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/log_view/LogViewScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/log_view/LogViewScreen.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.log_view&#10;&#10;import android.content.Intent&#10;import android.view.LayoutInflater&#10;import android.widget.CalendarView&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.CurrencyYen&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.working_timer.ui.components.DateRangePickerModal&#10;import com.example.working_timer.ui.components.FooterNavigationBar&#10;import com.example.working_timer.R&#10;import com.example.working_timer.ui.components.WorkItemComposable&#10;import java.text.NumberFormat&#10;import com.example.working_timer.util.BorderColor&#10;import com.example.working_timer.util.ButtonBackgroundColor&#10;import com.example.working_timer.data.db.Work&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;data class LogViewScreenState(&#10;    val uiState: LogViewUiState,&#10;    val showDateRangePicker: Boolean&#10;)&#10;&#10;data class LogViewScreenActions(&#10;    val onNavigateToTimer: () -&gt; Unit,&#10;    val onNavigateToEditWork: (Int, String, Boolean) -&gt; Unit,&#10;    val onDateSelected: (Int, Int, Int) -&gt; Unit,&#10;    val onShowDeleteDialog: (Work) -&gt; Unit,&#10;    val onHideDeleteDialog: () -&gt; Unit,&#10;    val onDeleteWork: (Work) -&gt; Unit,&#10;    val onShowDateRangePicker: () -&gt; Unit,&#10;    val onHideDateRangePicker: () -&gt; Unit,&#10;    val onDateRangeSelected: (Long?, Long?) -&gt; Unit,&#10;    val onHideSumDialog: () -&gt; Unit,&#10;    val onUpdateTotalWage: (Long) -&gt; Unit,&#10;    val onSetTimeCalculationMode: (TimeCalculationMode) -&gt; Unit&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogViewScreenHolder(&#10;    viewModel: LogViewViewModel = hiltViewModel(),&#10;    onNavigateToTimer: () -&gt; Unit,&#10;    onNavigateToEditWork: (Int, String, Boolean) -&gt; Unit&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Date Range Pickerの表示を制御するState&#10;    var showDateRangePicker by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        if (uiState.selectedDay.isNotEmpty()) {&#10;            viewModel.loadWorkList(uiState.selectedDay)&#10;        } else {&#10;            viewModel.init()&#10;        }&#10;    }&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiState,&#10;            showDateRangePicker = showDateRangePicker&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = onNavigateToTimer,&#10;            onNavigateToEditWork = onNavigateToEditWork,&#10;            onDateSelected = { year, month, dayOfMonth -&gt;&#10;                viewModel.setSelectedDay(year, month, dayOfMonth)&#10;            },&#10;            onShowDeleteDialog = { work -&gt;&#10;                viewModel.showDeleteDialog(work)&#10;            },&#10;            onHideDeleteDialog = {&#10;                viewModel.hideDeleteDialog()&#10;            },&#10;            onDeleteWork = { work -&gt;&#10;                viewModel.deleteWork(work)&#10;            },&#10;            onShowDateRangePicker = {&#10;                showDateRangePicker = true&#10;            },&#10;            onHideDateRangePicker = {&#10;                showDateRangePicker = false&#10;            },&#10;            onDateRangeSelected = { startDate, endDate -&gt;&#10;                if (startDate != null &amp;&amp; endDate != null) {&#10;                    viewModel.showSumDialog(startDate, endDate)&#10;                }&#10;            },&#10;            onHideSumDialog = {&#10;                viewModel.hideSumDialog()&#10;            },&#10;            onUpdateTotalWage = { wage -&gt;&#10;                viewModel.updateTotalWage(wage)&#10;            },&#10;            onSetTimeCalculationMode = { mode -&gt;&#10;                viewModel.setTimeCalculationMode(mode)&#10;            }&#10;        )&#10;    )&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogViewScreen(&#10;    state: LogViewScreenState,&#10;    actions: LogViewScreenActions&#10;) {&#10;    // Date formatter for calendar updates&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        AndroidView(&#10;            factory = { context -&gt;&#10;                val inflater = LayoutInflater.from(context)&#10;                val view = inflater.inflate(R.layout.calender_view, null)&#10;                val calendarView = view.findViewById&lt;CalendarView&gt;(R.id.calendarView)&#10;                calendarView.setOnDateChangeListener { _, year, month, dayOfMonth -&gt;&#10;                    actions.onDateSelected(year, month, dayOfMonth)&#10;                }&#10;                view&#10;            },&#10;            update = { view -&gt;&#10;                val calendarView = view as CalendarView&#10;                val dateMillis = if (state.uiState.selectedDay.isNotEmpty()) sdf.parse(state.uiState.selectedDay)?.time else null&#10;                if (dateMillis != null) {&#10;                    calendarView.date = dateMillis&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        HorizontalDivider(&#10;            color = BorderColor,&#10;            thickness = 1.dp&#10;        )&#10;&#10;        LazyColumn(modifier = Modifier.weight(0.8f)) {&#10;            itemsIndexed(state.uiState.workList) { index, work -&gt;&#10;                WorkItemComposable(&#10;                    work = work,&#10;                    onDelete = { actions.onShowDeleteDialog(work) },&#10;                    onEdit = {&#10;                        actions.onNavigateToEditWork(&#10;                            work.id,&#10;                            work.start_day,&#10;                            false&#10;                        )&#10;                    }&#10;                )&#10;                if (index &lt; state.uiState.workList.lastIndex) {&#10;                    HorizontalDivider(&#10;                        color = BorderColor,&#10;                        thickness = 1.dp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.Start&#10;        ) {&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            FloatingActionButton(&#10;                onClick = {&#10;                    actions.onNavigateToEditWork(&#10;                        0,&#10;                        state.uiState.selectedDay,&#10;                        true&#10;                    )&#10;                },&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.Add,&#10;                    modifier = Modifier&#10;                        .height(24.dp)&#10;                        .width(24.dp),&#10;                    contentDescription = &quot;追加&quot;&#10;                )&#10;            }&#10;            FloatingActionButton(&#10;                onClick = actions.onShowDateRangePicker,&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.CurrencyYen,&#10;                    contentDescription = &quot;給料計算&quot;&#10;                )&#10;            }&#10;        }&#10;        // 下部ナビゲーションバー&#10;        FooterNavigationBar(&#10;            selectedIndex = 1,&#10;            onTimerClick = actions.onNavigateToTimer,&#10;            onLogClick = {}&#10;        )&#10;    }&#10;&#10;    // 削除ダイアログ&#10;    if (state.uiState.showDeleteDialog &amp;&amp; state.uiState.workToDelete != null) {&#10;        AlertDialog(&#10;            onDismissRequest = actions.onHideDeleteDialog,&#10;            title = { Text(&quot;確認&quot;) },&#10;            text = { Text(&quot;本当にこの記録を削除しますか？&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = { actions.onDeleteWork(state.uiState.workToDelete) }) { Text(&quot;はい&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = actions.onHideDeleteDialog) { Text(&quot;いいえ&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    // 集計ダイアログ&#10;    if (state.uiState.showSumDialog) {&#10;        SumDialog(&#10;            startDate = state.uiState.sumStartDate,&#10;            endDate = state.uiState.sumEndDate,&#10;            totalHours = state.uiState.totalHours,&#10;            totalMinutes = state.uiState.totalMinutes,&#10;            totalWage = state.uiState.totalWage,&#10;            calculationMode = state.uiState.timeCalculationMode,&#10;            onDismiss = actions.onHideSumDialog,&#10;            onWageChange = actions.onUpdateTotalWage,&#10;            onCalculationModeChange = actions.onSetTimeCalculationMode&#10;        )&#10;    }&#10;&#10;    // 日付範囲選択ダイアログ&#10;    if (state.showDateRangePicker) {&#10;        DateRangePickerModal(&#10;            onDateRangeSelected = { pair -&gt;&#10;                val (startDate, endDate) = pair&#10;                actions.onDateRangeSelected(startDate, endDate)&#10;            },&#10;            onDismiss = actions.onHideDateRangePicker&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SumDialog(&#10;    startDate: Long?,&#10;    endDate: Long?,&#10;    totalHours: Long,&#10;    totalMinutes: Long,&#10;    totalWage: Long,&#10;    calculationMode: TimeCalculationMode,&#10;    onDismiss: () -&gt; Unit,&#10;    onWageChange: (Long) -&gt; Unit,&#10;    onCalculationModeChange: (TimeCalculationMode) -&gt; Unit&#10;) {&#10;    var wage by remember { mutableStateOf(0L) }&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(Unit) {&#10;        wage = 0L&#10;        onWageChange(wage)&#10;    }&#10;&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val formattedStartDate =&#10;        remember(startDate) { if (startDate != null) sdf.format(startDate) else &quot;N/A&quot; }&#10;    val formattedEndDate = remember(endDate) { if (endDate != null) sdf.format(endDate) else &quot;N/A&quot; }&#10;&#10;    val calculationModes = remember {&#10;        TimeCalculationMode.entries.map {&#10;            when (it) {&#10;                TimeCalculationMode.NORMAL -&gt; &quot;通常&quot;&#10;                TimeCalculationMode.ROUND_UP -&gt; &quot;繰り上げ&quot;&#10;                TimeCalculationMode.ROUND_DOWN -&gt; &quot;繰り下げ&quot;&#10;            }&#10;        }&#10;    }&#10;    val selectedModeIndex = calculationMode.ordinal&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;計算結果&quot;) },&#10;        text = {&#10;            Column {&#10;                Text(&#10;                    &quot;期間: ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;合計勤務時間: ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;給料: ${&#10;                        NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)&#10;                    } 円&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                OutlinedTextField(&#10;                    value = if (wage == 0L) &quot;&quot; else wage.toString(),&#10;                    textStyle = TextStyle(&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                    ),&#10;                    onValueChange = {&#10;                        wage = it.toLongOrNull() ?: 0L&#10;                        onWageChange(wage)&#10;                    },&#10;                    label = { Text(&quot;時給&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                SegmentedControl(&#10;                    items = calculationModes,&#10;                    selectedIndex = selectedModeIndex,&#10;                    onSelectionChange = { index -&gt;&#10;                        val mode = TimeCalculationMode.entries[index]&#10;                        onCalculationModeChange(mode)&#10;                        if (index != selectedModeIndex) {&#10;                            onWageChange(wage)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Row {&#10;                TextButton(onClick = {&#10;                    val lines = listOf(&#10;                        &quot;期間 ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                        &quot;時給 ${wage} 円&quot;,&#10;                        &quot;合計 ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                        &quot;給料 ${NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)} 円&quot;&#10;                    )&#10;                    val shareText = lines.joinToString(&quot;\n&quot;)&#10;                    val intent = Intent(Intent.ACTION_SEND).apply {&#10;                        type = &quot;text/plain&quot;&#10;                        putExtra(Intent.EXTRA_TEXT, shareText)&#10;                    }&#10;                    context.startActivity(Intent.createChooser(intent, &quot;共有&quot;))&#10;                }) { Text(&quot;共有&quot;) }&#10;                TextButton(onClick = onDismiss) { Text(&quot;閉じる&quot;) }&#10;            }&#10;&#10;        }&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun SegmentedControl(&#10;    items: List&lt;String&gt;,&#10;    selectedIndex: Int,&#10;    onSelectionChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        shape = RoundedCornerShape(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.LightGray.copy(alpha = 0.3f))&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(4.dp)&#10;        ) {&#10;            items.forEachIndexed { index, item -&gt;&#10;                val isSelected = selectedIndex == index&#10;                Card(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .padding(horizontal = 2.dp),&#10;                    shape = RoundedCornerShape(6.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = if (isSelected) MaterialTheme.colorScheme.primary&#10;                        else Color.Transparent&#10;                    ),&#10;                    onClick = { onSelectionChange(index) }&#10;                ) {&#10;                    Text(&#10;                        text = item,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 8.dp),&#10;                        textAlign = androidx.compose.ui.text.style.TextAlign.Center,&#10;                        color = if (isSelected) Color.White&#10;                        else MaterialTheme.colorScheme.onSurface,&#10;                        fontSize = MaterialTheme.typography.bodySmall.fontSize&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Empty State&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewEmpty() {&#10;    val emptyUiState = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = emptyList(),&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = emptyUiState,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;With Work List&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewWithWorkList() {&#10;    val sampleWorkList = listOf(&#10;        Work(&#10;            id = 1,&#10;            start_day = &quot;2025-01-02&quot;,&#10;            end_day = &quot;2025-01-02&quot;,&#10;            start_time = &quot;09:00&quot;,&#10;            end_time = &quot;17:00&quot;,&#10;            elapsed_time = 4800&#10;        ),&#10;        Work(&#10;            id = 2,&#10;            start_day = &quot;2025-01-02&quot;,&#10;            end_day = &quot;2025-01-02&quot;,&#10;            start_time = &quot;10:00&quot;,&#10;            end_time = &quot;14:00&quot;,&#10;            elapsed_time = 2400&#10;        ),&#10;        Work(&#10;            id = 3,&#10;            start_day = &quot;2025-01-02&quot;,&#10;            end_day = &quot;2025-01-02&quot;,&#10;            start_time = &quot;18:00&quot;,&#10;            end_time = &quot;22:00&quot;,&#10;            elapsed_time = 3800&#10;        )&#10;    )&#10;&#10;    val uiStateWithWork = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = sampleWorkList,&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiStateWithWork,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Delete Dialog&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewDeleteDialog() {&#10;    val workToDelete = Work(&#10;        id = 1,&#10;        start_day = &quot;2025-01-02&quot;,&#10;        end_day = &quot;2025-01-02&quot;,&#10;        start_time = &quot;09:00&quot;,&#10;        end_time = &quot;17:00&quot;,&#10;        elapsed_time = 480&#10;    )&#10;&#10;    val uiStateWithDeleteDialog = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = listOf(workToDelete),&#10;        showDeleteDialog = true,&#10;        workToDelete = workToDelete,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiStateWithDeleteDialog,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Sum Dialog&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewSumDialog() {&#10;    val uiStateWithSumDialog = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = emptyList(),&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = true,&#10;        sumStartDate = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L, // 1週間前&#10;        sumEndDate = System.currentTimeMillis(),&#10;        totalHours = 40L,&#10;        totalMinutes = 30L,&#10;        totalWage = 40500L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiStateWithSumDialog,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Date Range Picker&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewDateRangePicker() {&#10;    val uiState = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = emptyList(),&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiState,&#10;            showDateRangePicker = true&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.working_timer.ui.log_view&#10;&#10;import android.content.Intent&#10;import android.view.LayoutInflater&#10;import android.widget.CalendarView&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.CurrencyYen&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.working_timer.ui.components.DateRangePickerModal&#10;import com.example.working_timer.ui.components.FooterNavigationBar&#10;import com.example.working_timer.R&#10;import com.example.working_timer.ui.components.WorkItemComposable&#10;import java.text.NumberFormat&#10;import com.example.working_timer.util.BorderColor&#10;import com.example.working_timer.util.ButtonBackgroundColor&#10;import com.example.working_timer.data.db.Work&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;data class LogViewScreenState(&#10;    val uiState: LogViewUiState,&#10;    val showDateRangePicker: Boolean&#10;)&#10;&#10;data class LogViewScreenActions(&#10;    val onNavigateToTimer: () -&gt; Unit,&#10;    val onNavigateToEditWork: (Int, String, Boolean) -&gt; Unit,&#10;    val onDateSelected: (Int, Int, Int) -&gt; Unit,&#10;    val onShowDeleteDialog: (Work) -&gt; Unit,&#10;    val onHideDeleteDialog: () -&gt; Unit,&#10;    val onDeleteWork: (Work) -&gt; Unit,&#10;    val onShowDateRangePicker: () -&gt; Unit,&#10;    val onHideDateRangePicker: () -&gt; Unit,&#10;    val onDateRangeSelected: (Long?, Long?) -&gt; Unit,&#10;    val onHideSumDialog: () -&gt; Unit,&#10;    val onUpdateTotalWage: (Long) -&gt; Unit,&#10;    val onSetTimeCalculationMode: (TimeCalculationMode) -&gt; Unit&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogViewScreenHolder(&#10;    viewModel: LogViewViewModel = hiltViewModel(),&#10;    onNavigateToTimer: () -&gt; Unit,&#10;    onNavigateToEditWork: (Int, String, Boolean) -&gt; Unit&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Date Range Pickerの表示を制御するState&#10;    var showDateRangePicker by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        if (uiState.selectedDay.isNotEmpty()) {&#10;            viewModel.loadWorkList(uiState.selectedDay)&#10;        } else {&#10;            viewModel.init()&#10;        }&#10;    }&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiState,&#10;            showDateRangePicker = showDateRangePicker&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = onNavigateToTimer,&#10;            onNavigateToEditWork = onNavigateToEditWork,&#10;            onDateSelected = { year, month, dayOfMonth -&gt;&#10;                viewModel.setSelectedDay(year, month, dayOfMonth)&#10;            },&#10;            onShowDeleteDialog = { work -&gt;&#10;                viewModel.showDeleteDialog(work)&#10;            },&#10;            onHideDeleteDialog = {&#10;                viewModel.hideDeleteDialog()&#10;            },&#10;            onDeleteWork = { work -&gt;&#10;                viewModel.deleteWork(work)&#10;            },&#10;            onShowDateRangePicker = {&#10;                showDateRangePicker = true&#10;            },&#10;            onHideDateRangePicker = {&#10;                showDateRangePicker = false&#10;            },&#10;            onDateRangeSelected = { startDate, endDate -&gt;&#10;                if (startDate != null &amp;&amp; endDate != null) {&#10;                    viewModel.showSumDialog(startDate, endDate)&#10;                }&#10;            },&#10;            onHideSumDialog = {&#10;                viewModel.hideSumDialog()&#10;            },&#10;            onUpdateTotalWage = { wage -&gt;&#10;                viewModel.updateTotalWage(wage)&#10;            },&#10;            onSetTimeCalculationMode = { mode -&gt;&#10;                viewModel.setTimeCalculationMode(mode)&#10;            }&#10;        )&#10;    )&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogViewScreen(&#10;    state: LogViewScreenState,&#10;    actions: LogViewScreenActions&#10;) {&#10;    // Date formatter for calendar updates&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        AndroidView(&#10;            factory = { context -&gt;&#10;                val inflater = LayoutInflater.from(context)&#10;                val view = inflater.inflate(R.layout.calender_view, null)&#10;                val calendarView = view.findViewById&lt;CalendarView&gt;(R.id.calendarView)&#10;                calendarView.setOnDateChangeListener { _, year, month, dayOfMonth -&gt;&#10;                    actions.onDateSelected(year, month, dayOfMonth)&#10;                }&#10;                view&#10;            },&#10;            update = { view -&gt;&#10;                val calendarView = view as CalendarView&#10;                val dateMillis = if (state.uiState.selectedDay.isNotEmpty()) sdf.parse(state.uiState.selectedDay)?.time else null&#10;                if (dateMillis != null) {&#10;                    calendarView.date = dateMillis&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        HorizontalDivider(&#10;            color = BorderColor,&#10;            thickness = 1.dp&#10;        )&#10;&#10;        LazyColumn(modifier = Modifier.weight(0.8f)) {&#10;            itemsIndexed(state.uiState.workList) { index, work -&gt;&#10;                WorkItemComposable(&#10;                    work = work,&#10;                    onDelete = { actions.onShowDeleteDialog(work) },&#10;                    onEdit = {&#10;                        actions.onNavigateToEditWork(&#10;                            work.id,&#10;                            work.start_day,&#10;                            false&#10;                        )&#10;                    }&#10;                )&#10;                if (index &lt; state.uiState.workList.lastIndex) {&#10;                    HorizontalDivider(&#10;                        color = BorderColor,&#10;                        thickness = 1.dp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.Start&#10;        ) {&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            FloatingActionButton(&#10;                onClick = {&#10;                    actions.onNavigateToEditWork(&#10;                        0,&#10;                        state.uiState.selectedDay,&#10;                        true&#10;                    )&#10;                },&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.Add,&#10;                    modifier = Modifier&#10;                        .height(24.dp)&#10;                        .width(24.dp),&#10;                    contentDescription = &quot;追加&quot;&#10;                )&#10;            }&#10;            FloatingActionButton(&#10;                onClick = actions.onShowDateRangePicker,&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.CurrencyYen,&#10;                    contentDescription = &quot;給料計算&quot;&#10;                )&#10;            }&#10;        }&#10;        // 下部ナビゲーションバー&#10;        FooterNavigationBar(&#10;            selectedIndex = 1,&#10;            onTimerClick = actions.onNavigateToTimer,&#10;            onLogClick = {}&#10;        )&#10;    }&#10;&#10;    // 削除ダイアログ&#10;    if (state.uiState.showDeleteDialog &amp;&amp; state.uiState.workToDelete != null) {&#10;        AlertDialog(&#10;            onDismissRequest = actions.onHideDeleteDialog,&#10;            title = { Text(&quot;確認&quot;) },&#10;            text = { Text(&quot;本当にこの記録を削除しますか？&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = { actions.onDeleteWork(state.uiState.workToDelete) }) { Text(&quot;はい&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = actions.onHideDeleteDialog) { Text(&quot;いいえ&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    // 集計ダイアログ&#10;    if (state.uiState.showSumDialog) {&#10;        SumDialog(&#10;            startDate = state.uiState.sumStartDate,&#10;            endDate = state.uiState.sumEndDate,&#10;            totalHours = state.uiState.totalHours,&#10;            totalMinutes = state.uiState.totalMinutes,&#10;            totalWage = state.uiState.totalWage,&#10;            calculationMode = state.uiState.timeCalculationMode,&#10;            onDismiss = actions.onHideSumDialog,&#10;            onWageChange = actions.onUpdateTotalWage,&#10;            onCalculationModeChange = actions.onSetTimeCalculationMode&#10;        )&#10;    }&#10;&#10;    // 日付範囲選択ダイアログ&#10;    if (state.showDateRangePicker) {&#10;        DateRangePickerModal(&#10;            onDateRangeSelected = { pair -&gt;&#10;                val (startDate, endDate) = pair&#10;                actions.onDateRangeSelected(startDate, endDate)&#10;            },&#10;            onDismiss = actions.onHideDateRangePicker&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SumDialog(&#10;    startDate: Long?,&#10;    endDate: Long?,&#10;    totalHours: Long,&#10;    totalMinutes: Long,&#10;    totalWage: Long,&#10;    calculationMode: TimeCalculationMode,&#10;    onDismiss: () -&gt; Unit,&#10;    onWageChange: (Long) -&gt; Unit,&#10;    onCalculationModeChange: (TimeCalculationMode) -&gt; Unit&#10;) {&#10;    var wage by remember { mutableStateOf(0L) }&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(Unit) {&#10;        wage = 0L&#10;        onWageChange(wage)&#10;    }&#10;&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val formattedStartDate =&#10;        remember(startDate) { if (startDate != null) sdf.format(startDate) else &quot;N/A&quot; }&#10;    val formattedEndDate = remember(endDate) { if (endDate != null) sdf.format(endDate) else &quot;N/A&quot; }&#10;&#10;    val calculationModes = remember {&#10;        TimeCalculationMode.entries.map {&#10;            when (it) {&#10;                TimeCalculationMode.NORMAL -&gt; &quot;通常&quot;&#10;                TimeCalculationMode.ROUND_UP -&gt; &quot;繰り上げ&quot;&#10;                TimeCalculationMode.ROUND_DOWN -&gt; &quot;繰り下げ&quot;&#10;            }&#10;        }&#10;    }&#10;    val selectedModeIndex = calculationMode.ordinal&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;計算結果&quot;) },&#10;        text = {&#10;            Column {&#10;                Text(&#10;                    &quot;期間: ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;合計勤務時間: ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;給料: ${&#10;                        NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)&#10;                    } 円&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                OutlinedTextField(&#10;                    value = if (wage == 0L) &quot;&quot; else wage.toString(),&#10;                    textStyle = TextStyle(&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                    ),&#10;                    onValueChange = {&#10;                        wage = it.toLongOrNull() ?: 0L&#10;                        onWageChange(wage)&#10;                    },&#10;                    label = { Text(&quot;時給&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                SegmentedControl(&#10;                    items = calculationModes,&#10;                    selectedIndex = selectedModeIndex,&#10;                    onSelectionChange = { index -&gt;&#10;                        val mode = TimeCalculationMode.entries[index]&#10;                        onCalculationModeChange(mode)&#10;                        if (index != selectedModeIndex) {&#10;                            onWageChange(wage)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Row {&#10;                TextButton(onClick = {&#10;                    val lines = listOf(&#10;                        &quot;期間 ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                        &quot;時給 ${wage} 円&quot;,&#10;                        &quot;合計 ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                        &quot;給料 ${NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)} 円&quot;&#10;                    )&#10;                    val shareText = lines.joinToString(&quot;\n&quot;)&#10;                    val intent = Intent(Intent.ACTION_SEND).apply {&#10;                        type = &quot;text/plain&quot;&#10;                        putExtra(Intent.EXTRA_TEXT, shareText)&#10;                    }&#10;                    context.startActivity(Intent.createChooser(intent, &quot;共有&quot;))&#10;                }) { Text(&quot;共有&quot;) }&#10;                TextButton(onClick = onDismiss) { Text(&quot;閉じる&quot;) }&#10;            }&#10;&#10;        }&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun SegmentedControl(&#10;    items: List&lt;String&gt;,&#10;    selectedIndex: Int,&#10;    onSelectionChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        shape = RoundedCornerShape(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.LightGray.copy(alpha = 0.3f))&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(4.dp)&#10;        ) {&#10;            items.forEachIndexed { index, item -&gt;&#10;                val isSelected = selectedIndex == index&#10;                Card(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .padding(horizontal = 2.dp),&#10;                    shape = RoundedCornerShape(6.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = if (isSelected) MaterialTheme.colorScheme.primary&#10;                        else Color.Transparent&#10;                    ),&#10;                    onClick = { onSelectionChange(index) }&#10;                ) {&#10;                    Text(&#10;                        text = item,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 8.dp),&#10;                        textAlign = androidx.compose.ui.text.style.TextAlign.Center,&#10;                        color = if (isSelected) Color.White&#10;                        else MaterialTheme.colorScheme.onSurface,&#10;                        fontSize = MaterialTheme.typography.bodySmall.fontSize&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Empty State&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewEmpty() {&#10;    val emptyUiState = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = emptyList(),&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = emptyUiState,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;With Work List&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewWithWorkList() {&#10;    val sampleWorkList = listOf(&#10;        Work(&#10;            id = 1,&#10;            start_day = &quot;2025-01-02&quot;,&#10;            end_day = &quot;2025-01-02&quot;,&#10;            start_time = &quot;09:00&quot;,&#10;            end_time = &quot;17:00&quot;,&#10;            elapsed_time = 4800&#10;        ),&#10;        Work(&#10;            id = 2,&#10;            start_day = &quot;2025-01-02&quot;,&#10;            end_day = &quot;2025-01-02&quot;,&#10;            start_time = &quot;10:00&quot;,&#10;            end_time = &quot;14:00&quot;,&#10;            elapsed_time = 2400&#10;        ),&#10;        Work(&#10;            id = 3,&#10;            start_day = &quot;2025-01-02&quot;,&#10;            end_day = &quot;2025-01-02&quot;,&#10;            start_time = &quot;18:00&quot;,&#10;            end_time = &quot;22:00&quot;,&#10;            elapsed_time = 3800&#10;        )&#10;    )&#10;&#10;    val uiStateWithWork = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = sampleWorkList,&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiStateWithWork,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Delete Dialog&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewDeleteDialog() {&#10;    val workToDelete = Work(&#10;        id = 1,&#10;        start_day = &quot;2025-01-02&quot;,&#10;        end_day = &quot;2025-01-02&quot;,&#10;        start_time = &quot;09:00&quot;,&#10;        end_time = &quot;17:00&quot;,&#10;        elapsed_time = 480&#10;    )&#10;&#10;    val uiStateWithDeleteDialog = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = listOf(workToDelete),&#10;        showDeleteDialog = true,&#10;        workToDelete = workToDelete,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiStateWithDeleteDialog,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Sum Dialog&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewSumDialog() {&#10;    val uiStateWithSumDialog = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = emptyList(),&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = true,&#10;        sumStartDate = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L, // 1週間前&#10;        sumEndDate = System.currentTimeMillis(),&#10;        totalHours = 40L,&#10;        totalMinutes = 30L,&#10;        totalWage = 40500L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiStateWithSumDialog,&#10;            showDateRangePicker = false&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true, name = &quot;Date Range Picker&quot;)&#10;@Composable&#10;fun LogViewScreenPreviewDateRangePicker() {&#10;    val uiState = LogViewUiState(&#10;        selectedDay = &quot;2025-01-02&quot;,&#10;        workList = emptyList(),&#10;        showDeleteDialog = false,&#10;        workToDelete = null,&#10;        showSumDialog = false,&#10;        sumStartDate = null,&#10;        sumEndDate = null,&#10;        totalHours = 0L,&#10;        totalMinutes = 0L,&#10;        totalWage = 0L,&#10;        timeCalculationMode = TimeCalculationMode.NORMAL&#10;    )&#10;&#10;    LogViewScreen(&#10;        state = LogViewScreenState(&#10;            uiState = uiState,&#10;            showDateRangePicker = true&#10;        ),&#10;        actions = LogViewScreenActions(&#10;            onNavigateToTimer = {},&#10;            onNavigateToEditWork = { _, _, _ -&gt; },&#10;            onDateSelected = { _, _, _ -&gt; },&#10;            onShowDeleteDialog = {},&#10;            onHideDeleteDialog = {},&#10;            onDeleteWork = {},&#10;            onShowDateRangePicker = {},&#10;            onHideDateRangePicker = {},&#10;            onDateRangeSelected = { _, _ -&gt; },&#10;            onHideSumDialog = {},&#10;            onUpdateTotalWage = {},&#10;            onSetTimeCalculationMode = {}&#10;        )&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/main/MainViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/main/MainViewModel.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.main&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.working_timer.data.db.Work&#10;import com.example.working_timer.domain.repository.DataStoreManager&#10;import com.example.working_timer.domain.repository.TimerListener&#10;import com.example.working_timer.domain.repository.TimerManager&#10;import com.example.working_timer.domain.repository.WorkRepository&#10;import com.example.working_timer.util.Constants.ONE_MINUTE_MS&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import java.text.SimpleDateFormat&#10;import java.util.Calendar&#10;import java.util.Date&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;// UIの状態を保持するためのデータクラス&#10;data class TimerUiState(&#10;    val status: String = &quot;&quot;,&#10;    val timerText: String = &quot;00:00&quot;,&#10;    val isTimerRunning: Boolean = false,&#10;    val isPaused: Boolean = false,&#10;    val elapsedTime: Long = 0L,&#10;    val showSaveDialog: Boolean = false,&#10;    val dialogMessage: String = &quot;&quot;,&#10;    val isErrorDialog: Boolean = false,&#10;    val snackbarMessage: String? = null,&#10;    val navigateToLog: Boolean = false,&#10;)&#10;&#10;@HiltViewModel&#10;class MainViewModel @Inject constructor(&#10;    private val workRepository: WorkRepository,&#10;    private val timerManager: TimerManager,&#10;    private val dataStoreManager: DataStoreManager&#10;) : ViewModel(), TimerListener {&#10;    private val _uiState = MutableStateFlow(TimerUiState())&#10;    val uiState: StateFlow&lt;TimerUiState&gt; = _uiState&#10;&#10;    init {&#10;        timerManager.setListener(this)&#10;        loadElapsedTime()&#10;    }&#10;&#10;    private fun loadElapsedTime() {&#10;        viewModelScope.launch {&#10;            val savedElapsedTime = dataStoreManager.getElapsedTimeSync() ?: 0L&#10;            updateTimerText(savedElapsedTime)&#10;            updateUiState()&#10;        }&#10;    }&#10;&#10;    override fun onTimerTick(elapsedTime: Long) {&#10;        updateTimerText(elapsedTime)&#10;    }&#10;&#10;    override fun updateUI() {&#10;        updateUiState()&#10;    }&#10;&#10;    override fun onError(error: String) {&#10;        _uiState.value = _uiState.value.copy(snackbarMessage = error)&#10;    }&#10;&#10;    fun clearSnackbarMessage() {&#10;        _uiState.value = _uiState.value.copy(snackbarMessage = null)&#10;    }&#10;&#10;    private fun updateTimerText(elapsedTime: Long) {&#10;        val rep_sec_time = elapsedTime / 1000&#10;        val hours = (rep_sec_time / 3600).toInt()&#10;        val minutes = ((rep_sec_time / 60) % 60).toInt()&#10;        val seconds = (rep_sec_time % 60).toInt()&#10;        val formattedTime = if (hours &gt; 0) {&#10;            String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;        } else {&#10;            String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;        }&#10;        _uiState.value = _uiState.value.copy(timerText = formattedTime, elapsedTime = elapsedTime)&#10;    }&#10;&#10;    // UIの状態を更新するヘルパー関数&#10;    private fun updateUiState() {&#10;        val isRunning = timerManager.isTimerRunning()&#10;        val elapsedTime = timerManager.getElapsedTime()&#10;&#10;        val status = when {&#10;            isRunning -&gt; WORKING_STATUS&#10;            elapsedTime &gt; 0 -&gt; RESTING_STATUS&#10;            else -&gt; EMPTY_STATUS&#10;        }&#10;        _uiState.value = _uiState.value.copy(&#10;            status = status,&#10;            isTimerRunning = isRunning,&#10;            isPaused = !isRunning &amp;&amp; elapsedTime &gt; 0,&#10;            elapsedTime = elapsedTime&#10;        )&#10;        updateTimerText(elapsedTime)&#10;    }&#10;&#10;    fun startTimer() {&#10;        timerManager.startTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    fun pauseTimer() {&#10;        timerManager.pauseTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    fun resumeTimer() {&#10;        timerManager.resumeTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    fun stopTimer() {&#10;        timerManager.pauseTimer()&#10;        showSaveDialog()&#10;    }&#10;&#10;    private fun showSaveDialog() {&#10;        viewModelScope.launch {&#10;            val elapsedTime = timerManager.getElapsedTime()&#10;            val startDate = dataStoreManager.getStartDateSync()&#10;            val startTime = dataStoreManager.getStartTimeSync()&#10;&#10;            if (startDate == null || startTime == null) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    showSaveDialog = true,&#10;                    dialogMessage = ERROR_MSG_DATA_NOT_FOUND,&#10;                    isErrorDialog = true&#10;                )&#10;                return@launch&#10;            }&#10;&#10;            val rep_sec_time = elapsedTime / 1000&#10;            val hours = (rep_sec_time / 3600).toInt()&#10;            val minutes = ((rep_sec_time / 60) % 60).toInt()&#10;            val formattedTime = if (hours &gt; 0) {&#10;                String.format(&quot;%2d時間 %2d分&quot;, hours, minutes)&#10;            } else {&#10;                String.format(&quot;%2d分&quot;, minutes)&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                showSaveDialog = true,&#10;                dialogMessage = &quot;&quot;&quot;&#10;                開始日 ： $startDate&#10;                経過時間 ： $formattedTime&#10;&#10;                今回の作業記録を保存しますか？&#10;            &quot;&quot;&quot;.trimIndent(),&#10;                isErrorDialog = false&#10;            )&#10;        }&#10;    }&#10;&#10;    // ダイアログを閉じる&#10;    fun dismissSaveDialog() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSaveDialog = false,&#10;            isErrorDialog = false&#10;        )&#10;    }&#10;&#10;    // 作業を保存&#10;    fun saveWork() {&#10;        viewModelScope.launch {&#10;            val elapsedTime = timerManager.getElapsedTime()&#10;            val startDate = dataStoreManager.getStartDateSync() ?: return@launch&#10;            val startTime = dataStoreManager.getStartTimeSync() ?: return@launch&#10;&#10;            if (elapsedTime &lt; ONE_MINUTE_MS) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    showSaveDialog = true,&#10;                    dialogMessage = ERROR_MSG_TIME_TOO_SHORT,&#10;                    isErrorDialog = true&#10;                )&#10;                return@launch&#10;            }&#10;&#10;            val endTimeCalendar = Calendar.getInstance()&#10;            val sdfDate = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;            val endDate = sdfDate.format(endTimeCalendar.time)&#10;&#10;            val sdfTime = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;            val endTime = sdfTime.format(Date())&#10;            val saveElapsedTime = (elapsedTime / 1000 / 60) * 60&#10;&#10;            val work = Work(&#10;                start_day = startDate,&#10;                end_day = endDate,&#10;                start_time = startTime,&#10;                end_time = endTime,&#10;                elapsed_time = saveElapsedTime&#10;            )&#10;&#10;            // 保存処理&#10;            try {&#10;                workRepository.insert(work)&#10;                timerManager.stopTimer()&#10;                updateUiState()&#10;                dismissSaveDialog()&#10;                _uiState.value = _uiState.value.copy(navigateToLog = true)&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    showSaveDialog = true,&#10;                    dialogMessage = &quot;$ERROR_MSG_SAVE_FAILED ${e.message}&quot;,&#10;                    isErrorDialog = true&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // 作業を破棄&#10;    fun discardWork() {&#10;        timerManager.stopTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerManager.removeListener()&#10;    }&#10;&#10;    fun onNavigationHandled() {&#10;        _uiState.value = _uiState.value.copy(navigateToLog = false)&#10;    }&#10;&#10;    companion object {&#10;        const val WORKING_STATUS = &quot;労働中&quot;&#10;        const val RESTING_STATUS = &quot;休憩中&quot;&#10;        const val EMPTY_STATUS = &quot;&quot;&#10;        const val ERROR_MSG_SAVE_FAILED = &quot;保存に失敗しました。再度お試しください。\nエラー:&quot;&#10;        const val ERROR_MSG_TIME_TOO_SHORT = &quot;1分未満の作業は保存できません。再開または破棄を選択してください。&quot;&#10;        const val ERROR_MSG_DATA_NOT_FOUND = &quot;開始日または開始時刻が正しく取得できませんでした。&quot;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.working_timer.ui.main&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.working_timer.data.db.Work&#10;import com.example.working_timer.domain.repository.DataStoreManager&#10;import com.example.working_timer.domain.repository.TimerListener&#10;import com.example.working_timer.domain.repository.TimerManager&#10;import com.example.working_timer.domain.repository.WorkRepository&#10;import com.example.working_timer.util.Constants.ONE_MINUTE_MS&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import java.text.SimpleDateFormat&#10;import java.util.Calendar&#10;import java.util.Date&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;// UIの状態を保持するためのデータクラス&#10;data class TimerUiState(&#10;    val status: String = &quot;&quot;,&#10;    val timerText: String = &quot;00:00&quot;,&#10;    val isTimerRunning: Boolean = false,&#10;    val isPaused: Boolean = false,&#10;    val elapsedTime: Long = 0L,&#10;    val showSaveDialog: Boolean = false,&#10;    val dialogMessage: String = &quot;&quot;,&#10;    val isErrorDialog: Boolean = false,&#10;    val snackbarMessage: String? = null,&#10;    val navigateToLog: Boolean = false,&#10;)&#10;&#10;@HiltViewModel&#10;class MainViewModel @Inject constructor(&#10;    private val workRepository: WorkRepository,&#10;    private val timerManager: TimerManager,&#10;    private val dataStoreManager: DataStoreManager&#10;) : ViewModel(), TimerListener {&#10;    private val _uiState = MutableStateFlow(TimerUiState())&#10;    val uiState: StateFlow&lt;TimerUiState&gt; = _uiState&#10;&#10;    init {&#10;        timerManager.setListener(this)&#10;        loadElapsedTime()&#10;    }&#10;&#10;    private fun loadElapsedTime() {&#10;        viewModelScope.launch {&#10;            val savedElapsedTime = dataStoreManager.getElapsedTimeSync() ?: 0L&#10;            updateTimerText(savedElapsedTime)&#10;            updateUiState()&#10;        }&#10;    }&#10;&#10;    override fun onTimerTick(elapsedTime: Long) {&#10;        updateTimerText(elapsedTime)&#10;    }&#10;&#10;    override fun updateUI() {&#10;        updateUiState()&#10;    }&#10;&#10;    override fun onError(error: String) {&#10;        _uiState.value = _uiState.value.copy(snackbarMessage = error)&#10;    }&#10;&#10;    fun clearSnackbarMessage() {&#10;        _uiState.value = _uiState.value.copy(snackbarMessage = null)&#10;    }&#10;&#10;    private fun updateTimerText(elapsedTime: Long) {&#10;        val rep_sec_time = elapsedTime / 1000&#10;        val hours = (rep_sec_time / 3600).toInt()&#10;        val minutes = ((rep_sec_time / 60) % 60).toInt()&#10;        val seconds = (rep_sec_time % 60).toInt()&#10;        val formattedTime = if (hours &gt; 0) {&#10;            String.format(&quot;%02d:%02d:%02d&quot;, hours, minutes, seconds)&#10;        } else {&#10;            String.format(&quot;%02d:%02d&quot;, minutes, seconds)&#10;        }&#10;        _uiState.value = _uiState.value.copy(timerText = formattedTime, elapsedTime = elapsedTime)&#10;    }&#10;&#10;    // UIの状態を更新するヘルパー関数&#10;    private fun updateUiState() {&#10;        val isRunning = timerManager.isTimerRunning()&#10;        val elapsedTime = timerManager.getElapsedTime()&#10;&#10;        val status = when {&#10;            isRunning -&gt; WORKING_STATUS&#10;            elapsedTime &gt; 0 -&gt; RESTING_STATUS&#10;            else -&gt; EMPTY_STATUS&#10;        }&#10;        _uiState.value = _uiState.value.copy(&#10;            status = status,&#10;            isTimerRunning = isRunning,&#10;            isPaused = !isRunning &amp;&amp; elapsedTime &gt; 0,&#10;            elapsedTime = elapsedTime&#10;        )&#10;        updateTimerText(elapsedTime)&#10;    }&#10;&#10;    fun startTimer() {&#10;        timerManager.startTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    fun pauseTimer() {&#10;        timerManager.pauseTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    fun resumeTimer() {&#10;        timerManager.resumeTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    fun stopTimer() {&#10;        timerManager.pauseTimer()&#10;        showSaveDialog()&#10;    }&#10;&#10;    private fun showSaveDialog() {&#10;        viewModelScope.launch {&#10;            val elapsedTime = timerManager.getElapsedTime()&#10;            val startDate = dataStoreManager.getStartDateSync()&#10;            val startTime = dataStoreManager.getStartTimeSync()&#10;&#10;            if (startDate == null || startTime == null) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    showSaveDialog = true,&#10;                    dialogMessage = ERROR_MSG_DATA_NOT_FOUND,&#10;                    isErrorDialog = true&#10;                )&#10;                return@launch&#10;            }&#10;&#10;            val rep_sec_time = elapsedTime / 1000&#10;            val hours = (rep_sec_time / 3600).toInt()&#10;            val minutes = ((rep_sec_time / 60) % 60).toInt()&#10;            val formattedTime = if (hours &gt; 0) {&#10;                String.format(&quot;%2d時間 %2d分&quot;, hours, minutes)&#10;            } else {&#10;                String.format(&quot;%2d分&quot;, minutes)&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(&#10;                showSaveDialog = true,&#10;                dialogMessage = &quot;&quot;&quot;&#10;                開始日 ： $startDate&#10;                経過時間 ： $formattedTime&#10;&#10;                今回の作業記録を保存しますか？&#10;            &quot;&quot;&quot;.trimIndent(),&#10;                isErrorDialog = false&#10;            )&#10;        }&#10;    }&#10;&#10;    // ダイアログを閉じる&#10;    fun dismissSaveDialog() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSaveDialog = false,&#10;            isErrorDialog = false&#10;        )&#10;    }&#10;&#10;    // 作業を保存&#10;    fun saveWork() {&#10;        viewModelScope.launch {&#10;            val elapsedTime = timerManager.getElapsedTime()&#10;            val startDate = dataStoreManager.getStartDateSync() ?: return@launch&#10;            val startTime = dataStoreManager.getStartTimeSync() ?: return@launch&#10;&#10;            if (elapsedTime &lt; ONE_MINUTE_MS) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    showSaveDialog = true,&#10;                    dialogMessage = ERROR_MSG_TIME_TOO_SHORT,&#10;                    isErrorDialog = true&#10;                )&#10;                return@launch&#10;            }&#10;&#10;            val endTimeCalendar = Calendar.getInstance()&#10;            val sdfDate = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;            val endDate = sdfDate.format(endTimeCalendar.time)&#10;&#10;            val sdfTime = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;            val endTime = sdfTime.format(Date())&#10;            val saveElapsedTime = (elapsedTime / 1000 / 60) * 60&#10;&#10;            val work = Work(&#10;                start_day = startDate,&#10;                end_day = endDate,&#10;                start_time = startTime,&#10;                end_time = endTime,&#10;                elapsed_time = saveElapsedTime&#10;            )&#10;&#10;            // 保存処理&#10;            try {&#10;                workRepository.insert(work)&#10;                timerManager.stopTimer()&#10;                updateUiState()&#10;                dismissSaveDialog()&#10;                _uiState.value = _uiState.value.copy(navigateToLog = true)&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    showSaveDialog = true,&#10;                    dialogMessage = &quot;$ERROR_MSG_SAVE_FAILED ${e.message}&quot;,&#10;                    isErrorDialog = true&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // 作業を破棄&#10;    fun discardWork() {&#10;        timerManager.stopTimer()&#10;        updateUiState()&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerManager.removeListener()&#10;    }&#10;&#10;    fun onNavigationHandled() {&#10;        _uiState.value = _uiState.value.copy(navigateToLog = false)&#10;    }&#10;&#10;    companion object {&#10;        const val WORKING_STATUS = &quot;労働中&quot;&#10;        const val RESTING_STATUS = &quot;休憩中&quot;&#10;        const val EMPTY_STATUS = &quot;&quot;&#10;        const val ERROR_MSG_SAVE_FAILED = &quot;保存に失敗しました。再度お試しください。\nエラー:&quot;&#10;        const val ERROR_MSG_TIME_TOO_SHORT = &quot;1分未満の作業は保存できません。再開または破棄を選択してください。&quot;&#10;        const val ERROR_MSG_DATA_NOT_FOUND = &quot;開始日または開始時刻が正しく取得できませんでした。&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>