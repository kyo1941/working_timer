<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkScreen.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.app.Activity&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.withStyle&#10;import androidx.compose.ui.text.SpanStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.working_timer.ui.components.DatePickerModal&#10;import com.example.working_timer.ui.components.MaterialTimePickerDialog&#10;import com.example.working_timer.R&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EditWorkScreen(&#10;    editWorkViewModel: EditWorkViewModel = hiltViewModel(),&#10;    id: Int,&#10;    startDay: String,&#10;    isNew: Boolean,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showStartTimePicker by remember { mutableStateOf(false) }&#10;    var showStartDayPicker by remember { mutableStateOf(false) }&#10;    var showEndTimePicker by remember { mutableStateOf(false) }&#10;    var showEndDayPicker by remember { mutableStateOf(false) }&#10;&#10;    var showElapsedPicker by remember { mutableStateOf(false) }&#10;&#10;    val uiState by editWorkViewModel.uiState.collectAsState()&#10;&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // 初期値を設定する&#10;        editWorkViewModel.init(id, isNew, startDay)&#10;&#10;        // イベントを監視する&#10;        editWorkViewModel.uiEvent.collectLatest { event -&gt;&#10;            when (event) {&#10;                is EditWorkViewModel.UiEvent.ShowSnackbar -&gt; {&#10;                    scope.launch {&#10;                        snackbarHostState.showSnackbar(event.message)&#10;                    }&#10;                }&#10;                EditWorkViewModel.UiEvent.SaveSuccess -&gt; { onNavigateBack() }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },&#10;        modifier = modifier&#10;    ) { _ -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            val context = LocalContext.current&#10;            Text(&#10;                text = context.getString(if (isNew) R.string.new_record else R.string.edit_record),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp),&#10;            )&#10;&#10;            Spacer(modifier = Modifier.weight(0.3f))&#10;&#10;            Text(&quot;開始&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showStartDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.startDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showStartTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.startTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;終了&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showEndDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.endDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showEndTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.endTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;活動時間&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showElapsedPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            if (uiState.elapsedHour &gt; 0) {&#10;                                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                    append(String.format(&quot;%2d&quot;, uiState.elapsedHour))&#10;                                }&#10;                                append(&quot; 時間 &quot;)&#10;                            }&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(String.format(&quot;%2d&quot;, uiState.elapsedMinute))&#10;                            }&#10;                            append(&quot; 分&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(0.2f))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Button(&#10;                    onClick = {&#10;                        onNavigateBack()&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;キャンセル&quot;)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(24.dp))&#10;&#10;                Button(&#10;                    onClick = {&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            isNew = isNew,&#10;                            forceSave = false&#10;                        )&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;保存&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        if (showStartTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.startTime),&#10;                onDismiss = { showStartTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateStartTime(it)&#10;                    showStartTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showEndTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.endTime),&#10;                onDismiss = { showEndTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateEndTime(it)&#10;                    showEndTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showStartDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.startDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateStartDay(it)&#10;                    showStartDayPicker = false&#10;                },&#10;                onDismiss = { showStartDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showEndDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.endDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateEndDay(it)&#10;                    showEndDayPicker = false&#10;                },&#10;                onDismiss = { showEndDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showElapsedPicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = Pair(uiState.elapsedHour, uiState.elapsedMinute),&#10;                onDismiss = { showElapsedPicker = false },&#10;                onTimeSelected = { timeString -&gt;&#10;                    val (h, m) = timeString.split(&quot;:&quot;).map { it.toIntOrNull() ?: 0 }&#10;                    editWorkViewModel.updateElapsedTime(h, m)&#10;                    showElapsedPicker = false&#10;                },&#10;                showToggleIcon = false&#10;            )&#10;        }&#10;&#10;        if (uiState.showZeroMinutesError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearZeroMinutesError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;1分以上からのみ記録が可能です。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearZeroMinutesError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showStartEndError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearStartEndError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;開始時刻が終了時刻を超えています。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearStartEndError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showElapsedTimeOver) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearElapsedTimeOver() },&#10;                title = { Text(&quot;注意&quot;) },&#10;                text = { Text(&quot;活動時間が時間差より大きいです。\nこのまま保存しますか？&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        editWorkViewModel.clearElapsedTimeOver()&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            isNew = isNew,&#10;                            forceSave = true&#10;                        )&#10;                    }) {&#10;                        Text(&quot;保存&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearElapsedTimeOver() }) {&#10;                        Text(&quot;キャンセル&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun parseTime(time: String): Pair&lt;Int, Int&gt; {&#10;    val parts = time.split(&quot;:&quot;).mapNotNull { it.toIntOrNull() }&#10;    return if (parts.size == 2) Pair(parts[0], parts[1]) else Pair(0, 0)&#10;}&#10;&#10;fun formatMonthDay(fullDate: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;M/d&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(fullDate)&#10;        outputFormat.format(date)&#10;    } catch (e: Exception) {&#10;        fullDate&#10;    }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.app.Activity&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.withStyle&#10;import androidx.compose.ui.text.SpanStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.working_timer.ui.components.DatePickerModal&#10;import com.example.working_timer.ui.components.MaterialTimePickerDialog&#10;import com.example.working_timer.R&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EditWorkScreen(&#10;    editWorkViewModel: EditWorkViewModel = hiltViewModel(),&#10;    id: Int,&#10;    startDay: String,&#10;    isNew: Boolean,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showStartTimePicker by remember { mutableStateOf(false) }&#10;    var showStartDayPicker by remember { mutableStateOf(false) }&#10;    var showEndTimePicker by remember { mutableStateOf(false) }&#10;    var showEndDayPicker by remember { mutableStateOf(false) }&#10;&#10;    var showElapsedPicker by remember { mutableStateOf(false) }&#10;&#10;    val uiState by editWorkViewModel.uiState.collectAsState()&#10;&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // 初期値を設定する&#10;        editWorkViewModel.init(id, isNew, startDay)&#10;&#10;        // イベントを監視する&#10;        editWorkViewModel.uiEvent.collectLatest { event -&gt;&#10;            when (event) {&#10;                is EditWorkViewModel.UiEvent.ShowSnackbar -&gt; {&#10;                    scope.launch {&#10;                        snackbarHostState.showSnackbar(event.message)&#10;                    }&#10;                }&#10;                EditWorkViewModel.UiEvent.SaveSuccess -&gt; { onNavigateBack() }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },&#10;        modifier = modifier&#10;    ) { _ -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            val context = LocalContext.current&#10;            Text(&#10;                text = context.getString(if (isNew) R.string.new_record else R.string.edit_record),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp),&#10;            )&#10;&#10;            Spacer(modifier = Modifier.weight(0.3f))&#10;&#10;            Text(&quot;開始&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showStartDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.startDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showStartTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.startTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;終了&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showEndDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.endDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showEndTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.endTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;活動時間&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showElapsedPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            if (uiState.elapsedHour &gt; 0) {&#10;                                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                    append(String.format(&quot;%2d&quot;, uiState.elapsedHour))&#10;                                }&#10;                                append(&quot; 時間 &quot;)&#10;                            }&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(String.format(&quot;%2d&quot;, uiState.elapsedMinute))&#10;                            }&#10;                            append(&quot; 分&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(0.2f))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Button(&#10;                    onClick = {&#10;                        onNavigateBack()&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;キャンセル&quot;)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(24.dp))&#10;&#10;                Button(&#10;                    onClick = {&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            isNew = isNew,&#10;                            forceSave = false&#10;                        )&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;保存&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        if (showStartTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.startTime),&#10;                onDismiss = { showStartTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateStartTime(it)&#10;                    showStartTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showEndTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.endTime),&#10;                onDismiss = { showEndTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateEndTime(it)&#10;                    showEndTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showStartDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.startDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateStartDay(it)&#10;                    showStartDayPicker = false&#10;                },&#10;                onDismiss = { showStartDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showEndDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.endDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateEndDay(it)&#10;                    showEndDayPicker = false&#10;                },&#10;                onDismiss = { showEndDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showElapsedPicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = Pair(uiState.elapsedHour, uiState.elapsedMinute),&#10;                onDismiss = { showElapsedPicker = false },&#10;                onTimeSelected = { timeString -&gt;&#10;                    val (h, m) = timeString.split(&quot;:&quot;).map { it.toIntOrNull() ?: 0 }&#10;                    editWorkViewModel.updateElapsedTime(h, m)&#10;                    showElapsedPicker = false&#10;                },&#10;                showToggleIcon = false&#10;            )&#10;        }&#10;&#10;        if (uiState.showZeroMinutesError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearZeroMinutesError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;1分以上からのみ記録が可能です。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearZeroMinutesError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showStartEndError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearStartEndError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;開始時刻が終了時刻を超えています。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearStartEndError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showElapsedTimeOver) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearElapsedTimeOver() },&#10;                title = { Text(&quot;注意&quot;) },&#10;                text = { Text(&quot;活動時間が時間差より大きいです。\nこのまま保存しますか？&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        editWorkViewModel.clearElapsedTimeOver()&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            isNew = isNew,&#10;                            forceSave = true&#10;                        )&#10;                    }) {&#10;                        Text(&quot;保存&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearElapsedTimeOver() }) {&#10;                        Text(&quot;キャンセル&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun parseTime(time: String): Pair&lt;Int, Int&gt; {&#10;    val parts = time.split(&quot;:&quot;).mapNotNull { it.toIntOrNull() }&#10;    return if (parts.size == 2) Pair(parts[0], parts[1]) else Pair(0, 0)&#10;}&#10;&#10;fun formatMonthDay(fullDate: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;M/d&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(fullDate)&#10;        outputFormat.format(date)&#10;    } catch (e: Exception) {&#10;        fullDate&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkViewModel.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.database.sqlite.SQLiteException&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.working_timer.data.db.Work&#10;import com.example.working_timer.domain.repository.WorkRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asSharedFlow&#10;import kotlinx.coroutines.launch&#10;import java.text.ParseException&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;data class EditWorkUiState(&#10;    val startDay: String = &quot;&quot;,&#10;    val endDay: String = &quot;&quot;,&#10;    val startTime: String = &quot;&quot;,&#10;    val endTime: String = &quot;&quot;,&#10;    val elapsedHour: Int = 0,&#10;    val elapsedMinute: Int = 0,&#10;    val showZeroMinutesError: Boolean = false,&#10;    val showStartEndError: Boolean = false,&#10;    val showElapsedTimeOver: Boolean = false&#10;)&#10;&#10;@HiltViewModel&#10;class EditWorkViewModel @Inject constructor(&#10;    private val workRepository: WorkRepository&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(EditWorkUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    sealed class UiEvent {&#10;        data class ShowSnackbar(val message: String) : UiEvent()&#10;        object SaveSuccess : UiEvent()&#10;    }&#10;&#10;    private val _uiEvent = MutableSharedFlow&lt;UiEvent&gt;()&#10;    val uiEvent = _uiEvent.asSharedFlow()&#10;&#10;    private companion object {&#10;        private const val DATE_TIME_PATTERN = &quot;yyyy-MM-dd HH:mm&quot;&#10;    }&#10;&#10;    fun init(id: Int, isNew: Boolean, startDay: String) {&#10;        if (isNew) {&#10;            // 新規作成時は初期値を設定する&#10;            _uiState.value = _uiState.value.copy(&#10;                startDay = startDay,&#10;                endDay = startDay,&#10;                startTime = &quot;00:00&quot;,&#10;                endTime = &quot;00:00&quot;,&#10;                elapsedHour = 0,&#10;                elapsedMinute = 0&#10;            )&#10;        } else {&#10;            // DBから記録を読み込む&#10;            getWork(id)&#10;        }&#10;    }&#10;&#10;    fun saveWork(&#10;        id: Int,&#10;        isNew: Boolean,&#10;        forceSave: Boolean = false&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentState = _uiState.value&#10;                val elapsedTime = currentState.elapsedHour * 3600 + currentState.elapsedMinute * 60&#10;&#10;                val dateTimeFormat = SimpleDateFormat(DATE_TIME_PATTERN, Locale.getDefault())&#10;                val startDateTimeMillis = try { dateTimeFormat.parse(&quot;${currentState.startDay} ${currentState.startTime}&quot;)?.time } catch (e: ParseException) { null }&#10;                val endDateTimeMillis = try { dateTimeFormat.parse(&quot;${currentState.endDay} ${currentState.endTime}&quot;)?.time } catch (e: ParseException) { null }&#10;&#10;                if (startDateTimeMillis == null || endDateTimeMillis == null) {&#10;                    _uiEvent.emit(UiEvent.ShowSnackbar(&quot;日付または時刻の形式が無効です。&quot;))&#10;                    return@launch&#10;                }&#10;&#10;                if (elapsedTime &lt;= 0) {&#10;                    _uiState.value = _uiState.value.copy(showZeroMinutesError = true)&#10;                    return@launch&#10;                }&#10;&#10;                if (startDateTimeMillis &gt; endDateTimeMillis) {&#10;                    _uiState.value = _uiState.value.copy(showStartEndError = true)&#10;                    return@launch&#10;                }&#10;&#10;                val diffSeconds = (endDateTimeMillis - startDateTimeMillis) / 1000&#10;                if (!forceSave &amp;&amp; diffSeconds &lt; elapsedTime) {&#10;                    _uiState.value = _uiState.value.copy(showElapsedTimeOver = true)&#10;                    return@launch&#10;                }&#10;&#10;                performSave(id, currentState.startDay, currentState.startTime, currentState.endDay, currentState.endTime, elapsedTime, isNew)&#10;&#10;            } catch (e: SQLiteException) {&#10;                _uiEvent.emit(UiEvent.ShowSnackbar(&quot;データベースエラーが発生しました。&quot;))&#10;            } catch (e: Exception) {&#10;                _uiEvent.emit(UiEvent.ShowSnackbar(&quot;予期しないエラーが発生しました: ${e.localizedMessage ?: &quot;詳細不明&quot;}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun performSave(&#10;        id: Int,&#10;        startDay: String,&#10;        startTime: String,&#10;        endDay: String,&#10;        endTime: String,&#10;        elapsedTime: Int,&#10;        isNew: Boolean&#10;    ) {&#10;        if (!isNew) {&#10;            val work = Work(&#10;                id = id,&#10;                start_day = startDay,&#10;                start_time = startTime,&#10;                end_day = endDay,&#10;                end_time = endTime,&#10;                elapsed_time = elapsedTime&#10;            )&#10;            workRepository.update(work)&#10;        } else {&#10;            val work = Work(&#10;                start_day = startDay,&#10;                start_time = startTime,&#10;                end_day = endDay,&#10;                end_time = endTime,&#10;                elapsed_time = elapsedTime&#10;            )&#10;            workRepository.insert(work)&#10;        }&#10;        _uiEvent.emit(UiEvent.SaveSuccess)&#10;    }&#10;&#10;    private fun getWork(id: Int) {&#10;        viewModelScope.launch {&#10;            workRepository.getWork(id).collect { work -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    startDay = work.start_day,&#10;                    endDay = work.end_day,&#10;                    startTime = work.start_time,&#10;                    endTime = work.end_time,&#10;                    elapsedHour = work.elapsed_time / 3600,&#10;                    elapsedMinute = (work.elapsed_time % 3600) / 60&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateStartDay(value: String) {&#10;        _uiState.value = _uiState.value.copy(startDay = value)&#10;    }&#10;&#10;    fun updateEndDay(value: String) {&#10;        _uiState.value = _uiState.value.copy(endDay = value)&#10;    }&#10;&#10;    fun updateStartTime(value: String) {&#10;        _uiState.value = _uiState.value.copy(startTime = value)&#10;    }&#10;&#10;    fun updateEndTime(value: String) {&#10;        _uiState.value = _uiState.value.copy(endTime = value)&#10;    }&#10;&#10;    fun updateElapsedTime(hour: Int, minute: Int) {&#10;        _uiState.value = _uiState.value.copy(elapsedHour = hour, elapsedMinute = minute)&#10;    }&#10;&#10;    fun clearZeroMinutesError() {&#10;        _uiState.value = _uiState.value.copy(showZeroMinutesError = false)&#10;    }&#10;&#10;    fun clearStartEndError() {&#10;        _uiState.value = _uiState.value.copy(showStartEndError = false)&#10;    }&#10;&#10;    fun clearElapsedTimeOver() {&#10;        _uiState.value = _uiState.value.copy(showElapsedTimeOver = false)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.database.sqlite.SQLiteException&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.working_timer.data.db.Work&#10;import com.example.working_timer.domain.repository.WorkRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asSharedFlow&#10;import kotlinx.coroutines.launch&#10;import java.text.ParseException&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;data class EditWorkUiState(&#10;    val startDay: String = &quot;&quot;,&#10;    val endDay: String = &quot;&quot;,&#10;    val startTime: String = &quot;&quot;,&#10;    val endTime: String = &quot;&quot;,&#10;    val elapsedHour: Int = 0,&#10;    val elapsedMinute: Int = 0,&#10;    val showZeroMinutesError: Boolean = false,&#10;    val showStartEndError: Boolean = false,&#10;    val showElapsedTimeOver: Boolean = false&#10;)&#10;&#10;@HiltViewModel&#10;class EditWorkViewModel @Inject constructor(&#10;    private val workRepository: WorkRepository&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(EditWorkUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    sealed class UiEvent {&#10;        data class ShowSnackbar(val message: String) : UiEvent()&#10;        object SaveSuccess : UiEvent()&#10;    }&#10;&#10;    private val _uiEvent = MutableSharedFlow&lt;UiEvent&gt;()&#10;    val uiEvent = _uiEvent.asSharedFlow()&#10;&#10;    private companion object {&#10;        private const val DATE_TIME_PATTERN = &quot;yyyy-MM-dd HH:mm&quot;&#10;    }&#10;&#10;    fun init(id: Int, isNew: Boolean, startDay: String) {&#10;        if (isNew) {&#10;            // 新規作成時は初期値を設定する&#10;            _uiState.value = _uiState.value.copy(&#10;                startDay = startDay,&#10;                endDay = startDay,&#10;                startTime = &quot;00:00&quot;,&#10;                endTime = &quot;00:00&quot;,&#10;                elapsedHour = 0,&#10;                elapsedMinute = 0&#10;            )&#10;        } else {&#10;            // DBから記録を読み込む&#10;            getWork(id)&#10;        }&#10;    }&#10;&#10;    fun saveWork(&#10;        id: Int,&#10;        isNew: Boolean,&#10;        forceSave: Boolean = false&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentState = _uiState.value&#10;                val elapsedTime = currentState.elapsedHour * 3600 + currentState.elapsedMinute * 60&#10;&#10;                val dateTimeFormat = SimpleDateFormat(DATE_TIME_PATTERN, Locale.getDefault())&#10;                val startDateTimeMillis = try { dateTimeFormat.parse(&quot;${currentState.startDay} ${currentState.startTime}&quot;)?.time } catch (e: ParseException) { null }&#10;                val endDateTimeMillis = try { dateTimeFormat.parse(&quot;${currentState.endDay} ${currentState.endTime}&quot;)?.time } catch (e: ParseException) { null }&#10;&#10;                if (startDateTimeMillis == null || endDateTimeMillis == null) {&#10;                    _uiEvent.emit(UiEvent.ShowSnackbar(&quot;日付または時刻の形式が無効です。&quot;))&#10;                    return@launch&#10;                }&#10;&#10;                if (elapsedTime &lt;= 0) {&#10;                    _uiState.value = _uiState.value.copy(showZeroMinutesError = true)&#10;                    return@launch&#10;                }&#10;&#10;                if (startDateTimeMillis &gt; endDateTimeMillis) {&#10;                    _uiState.value = _uiState.value.copy(showStartEndError = true)&#10;                    return@launch&#10;                }&#10;&#10;                val diffSeconds = (endDateTimeMillis - startDateTimeMillis) / 1000&#10;                if (!forceSave &amp;&amp; diffSeconds &lt; elapsedTime) {&#10;                    _uiState.value = _uiState.value.copy(showElapsedTimeOver = true)&#10;                    return@launch&#10;                }&#10;&#10;                // データベースへの保存処理&#10;                if (!isNew) {&#10;                    val work = Work(&#10;                        id = id,&#10;                        start_day = currentState.startDay,&#10;                        start_time = currentState.startTime,&#10;                        end_day = currentState.endDay,&#10;                        end_time = currentState.endTime,&#10;                        elapsed_time = elapsedTime&#10;                    )&#10;                    workRepository.update(work)&#10;                } else {&#10;                    val work = Work(&#10;                        start_day = currentState.startDay,&#10;                        start_time = currentState.startTime,&#10;                        end_day = currentState.endDay,&#10;                        end_time = currentState.endTime,&#10;                        elapsed_time = elapsedTime&#10;                    )&#10;                    workRepository.insert(work)&#10;                }&#10;                _uiEvent.emit(UiEvent.SaveSuccess)&#10;&#10;            } catch (e: SQLiteException) {&#10;                _uiEvent.emit(UiEvent.ShowSnackbar(&quot;データベースエラーが発生しました。&quot;))&#10;            } catch (e: Exception) {&#10;                _uiEvent.emit(UiEvent.ShowSnackbar(&quot;予期しないエラーが発生しました: ${e.localizedMessage ?: &quot;詳細不明&quot;}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun getWork(id: Int) {&#10;        viewModelScope.launch {&#10;            workRepository.getWork(id).collect { work -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    startDay = work.start_day,&#10;                    endDay = work.end_day,&#10;                    startTime = work.start_time,&#10;                    endTime = work.end_time,&#10;                    elapsedHour = work.elapsed_time / 3600,&#10;                    elapsedMinute = (work.elapsed_time % 3600) / 60&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateStartDay(value: String) {&#10;        _uiState.value = _uiState.value.copy(startDay = value)&#10;    }&#10;&#10;    fun updateEndDay(value: String) {&#10;        _uiState.value = _uiState.value.copy(endDay = value)&#10;    }&#10;&#10;    fun updateStartTime(value: String) {&#10;        _uiState.value = _uiState.value.copy(startTime = value)&#10;    }&#10;&#10;    fun updateEndTime(value: String) {&#10;        _uiState.value = _uiState.value.copy(endTime = value)&#10;    }&#10;&#10;    fun updateElapsedTime(hour: Int, minute: Int) {&#10;        _uiState.value = _uiState.value.copy(elapsedHour = hour, elapsedMinute = minute)&#10;    }&#10;&#10;    fun clearZeroMinutesError() {&#10;        _uiState.value = _uiState.value.copy(showZeroMinutesError = false)&#10;    }&#10;&#10;    fun clearStartEndError() {&#10;        _uiState.value = _uiState.value.copy(showStartEndError = false)&#10;    }&#10;&#10;    fun clearElapsedTimeOver() {&#10;        _uiState.value = _uiState.value.copy(showElapsedTimeOver = false)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>