<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/edit_work/EditWorkScreen.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.app.Activity&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.withStyle&#10;import androidx.compose.ui.text.SpanStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.working_timer.ui.components.DatePickerModal&#10;import com.example.working_timer.ui.components.MaterialTimePickerDialog&#10;import com.example.working_timer.R&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EditWorkScreen(&#10;    editWorkViewModel: EditWorkViewModel = hiltViewModel(),&#10;    id: Int,&#10;    startDay: String,&#10;    isNew: Boolean,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showStartTimePicker by remember { mutableStateOf(false) }&#10;    var showStartDayPicker by remember { mutableStateOf(false) }&#10;    var showEndTimePicker by remember { mutableStateOf(false) }&#10;    var showEndDayPicker by remember { mutableStateOf(false) }&#10;&#10;    var showElapsedPicker by remember { mutableStateOf(false) }&#10;&#10;    val uiState by editWorkViewModel.uiState.collectAsState()&#10;&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // 初期値を設定する&#10;        editWorkViewModel.init(id, isNew, startDay)&#10;&#10;        // イベントを監視する&#10;        editWorkViewModel.uiEvent.collectLatest { event -&gt;&#10;            when (event) {&#10;                is EditWorkViewModel.UiEvent.ShowSnackbar -&gt; {&#10;                    scope.launch {&#10;                        snackbarHostState.showSnackbar(event.message)&#10;                    }&#10;                }&#10;                EditWorkViewModel.UiEvent.SaveSuccess -&gt; { onNavigateBack() }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },&#10;        modifier = modifier&#10;    ) { _ -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            val context = LocalContext.current&#10;            Text(&#10;                text = context.getString(if (isNew) R.string.new_record else R.string.edit_record),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp),&#10;            )&#10;&#10;            Spacer(modifier = Modifier.weight(0.3f))&#10;&#10;            Text(&quot;開始&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showStartDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.startDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showStartTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.startTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;終了&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showEndDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.endDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showEndTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.endTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;活動時間&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showElapsedPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            if (uiState.elapsedHour &gt; 0) {&#10;                                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                    append(String.format(&quot;%2d&quot;, uiState.elapsedHour))&#10;                                }&#10;                                append(&quot; 時間 &quot;)&#10;                            }&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(String.format(&quot;%2d&quot;, uiState.elapsedMinute))&#10;                            }&#10;                            append(&quot; 分&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(0.2f))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Button(&#10;                    onClick = {&#10;                        onNavigateBack()&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;キャンセル&quot;)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(24.dp))&#10;&#10;                Button(&#10;                    onClick = {&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        editWorkViewModel.saveWork(&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            id = id,&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            isNew = isNew,&#10;                            forceSave = false&#10;                        )&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;保存&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        if (showStartTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.startTime),&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                onDismiss = { showStartTimePicker = false },&#10;                onTimeSelected = {&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                    editWorkViewModel.updateStartTime(it)&#10;                    showStartTimePicker = false&#10;                }&#10;            )&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;        }&#10;&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;        if (showEndTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.endTime),&#10;                onDismiss = { showEndTimePicker = false },&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateEndTime(it)&#10;                            startDay = uiState.startDay,&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                    showEndTimePicker = false&#10;                }&#10;            )&#10;        }&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;&#10;        if (showStartDayPicker) {&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;            DatePickerModal(&#10;                initialDate = uiState.startDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateStartDay(it)&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                    showStartDayPicker = false&#10;                },&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                onDismiss = { showStartDayPicker = false }&#10;            )&#10;        }&#10;&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;        if (showEndDayPicker) {&#10;            DatePickerModal(&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                initialDate = uiState.endDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateEndDay(it)&#10;                    showEndDayPicker = false&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                },&#10;                onDismiss = { showEndDayPicker = false }&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;            )&#10;        }&#10;&#10;        if (showElapsedPicker) {&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;            MaterialTimePickerDialog(&#10;                initialTime = Pair(uiState.elapsedHour, uiState.elapsedMinute),&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                onDismiss = { showElapsedPicker = false },&#10;                onTimeSelected = { timeString -&gt;&#10;                    val (h, m) = timeString.split(&quot;:&quot;).map { it.toIntOrNull() ?: 0 }&#10;                    editWorkViewModel.updateElapsedTime(h, m)&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                    showElapsedPicker = false&#10;                },&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                showToggleIcon = false&#10;            )&#10;        }&#10;&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;        if (uiState.showZeroMinutesError) {&#10;            AlertDialog(&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                onDismissRequest = { editWorkViewModel.clearZeroMinutesError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;1分以上からのみ記録が可能です。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearZeroMinutesError() }) {&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;        }&#10;&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;        if (uiState.showStartEndError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearStartEndError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                text = { Text(&quot;開始時刻が終了時刻を超えています。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearStartEndError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                }&#10;            )&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;        }&#10;&#10;        if (uiState.showElapsedTimeOver) {&#10;            AlertDialog(&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                onDismissRequest = { editWorkViewModel.clearElapsedTimeOver() },&#10;                title = { Text(&quot;注意&quot;) },&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                text = { Text(&quot;活動時間が時間差より大きいです。\nこのまま保存しますか？&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        editWorkViewModel.clearElapsedTimeOver()&#10;                        val newElapsed = uiState.elapsedHour * 3600 + uiState.elapsedMinute * 60&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            startDay = uiState.startDay,&#10;&#10;&#10;&#10;                            startTime = uiState.startTime,&#10;                            endDay = uiState.endDay,&#10;                            endTime = uiState.endTime,&#10;                            elapsedTime = newElapsed,&#10;                            isNew = isNew,&#10;                            forceSave = true&#10;                        )&#10;                    }) {&#10;                        Text(&quot;保存&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;&#10;&#10;&#10;                    TextButton(onClick = { editWorkViewModel.clearElapsedTimeOver() }) {&#10;                        Text(&quot;キャンセル&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun parseTime(time: String): Pair&lt;Int, Int&gt; {&#10;    val parts = time.split(&quot;:&quot;).mapNotNull { it.toIntOrNull() }&#10;    return if (parts.size == 2) Pair(parts[0], parts[1]) else Pair(0, 0)&#10;&#10;&#10;&#10;}&#10;&#10;fun formatMonthDay(fullDate: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;M/d&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(fullDate)&#10;        outputFormat.format(date)&#10;    } catch (e: Exception) {&#10;        fullDate&#10;    }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.working_timer.ui.edit_work&#10;&#10;import android.app.Activity&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.withStyle&#10;import androidx.compose.ui.text.SpanStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.example.working_timer.ui.components.DatePickerModal&#10;import com.example.working_timer.ui.components.MaterialTimePickerDialog&#10;import com.example.working_timer.R&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EditWorkScreen(&#10;    editWorkViewModel: EditWorkViewModel = hiltViewModel(),&#10;    id: Int,&#10;    startDay: String,&#10;    isNew: Boolean,&#10;    onNavigateBack: () -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showStartTimePicker by remember { mutableStateOf(false) }&#10;    var showStartDayPicker by remember { mutableStateOf(false) }&#10;    var showEndTimePicker by remember { mutableStateOf(false) }&#10;    var showEndDayPicker by remember { mutableStateOf(false) }&#10;&#10;    var showElapsedPicker by remember { mutableStateOf(false) }&#10;&#10;    val uiState by editWorkViewModel.uiState.collectAsState()&#10;&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    LaunchedEffect(Unit) {&#10;        // 初期値を設定する&#10;        editWorkViewModel.init(id, isNew, startDay)&#10;&#10;        // イベントを監視する&#10;        editWorkViewModel.uiEvent.collectLatest { event -&gt;&#10;            when (event) {&#10;                is EditWorkViewModel.UiEvent.ShowSnackbar -&gt; {&#10;                    scope.launch {&#10;                        snackbarHostState.showSnackbar(event.message)&#10;                    }&#10;                }&#10;                EditWorkViewModel.UiEvent.SaveSuccess -&gt; { onNavigateBack() }&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },&#10;        modifier = modifier&#10;    ) { _ -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            val context = LocalContext.current&#10;            Text(&#10;                text = context.getString(if (isNew) R.string.new_record else R.string.edit_record),&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp),&#10;            )&#10;&#10;            Spacer(modifier = Modifier.weight(0.3f))&#10;&#10;            Text(&quot;開始&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showStartDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.startDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showStartTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.startTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;終了&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showEndDayPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(formatMonthDay(uiState.endDay))&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;                Spacer(modifier = Modifier.width(32.dp))&#10;                TextButton(onClick = { showEndTimePicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(uiState.endTime)&#10;                            }&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Text(&quot;活動時間&quot;)&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                TextButton(onClick = { showElapsedPicker = true }) {&#10;                    Text(&#10;                        text = buildAnnotatedString {&#10;                            if (uiState.elapsedHour &gt; 0) {&#10;                                withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                    append(String.format(&quot;%2d&quot;, uiState.elapsedHour))&#10;                                }&#10;                                append(&quot; 時間 &quot;)&#10;                            }&#10;                            withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {&#10;                                append(String.format(&quot;%2d&quot;, uiState.elapsedMinute))&#10;                            }&#10;                            append(&quot; 分&quot;)&#10;                        },&#10;                        style = MaterialTheme.typography.headlineSmall.copy(&#10;                            textDecoration = TextDecoration.Underline,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    )&#10;&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(0.2f))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Button(&#10;                    onClick = {&#10;                        onNavigateBack()&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;キャンセル&quot;)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(24.dp))&#10;&#10;                Button(&#10;                    onClick = {&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            isNew = isNew,&#10;                            forceSave = false&#10;                        )&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;保存&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;        }&#10;&#10;        if (showStartTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.startTime),&#10;                onDismiss = { showStartTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateStartTime(it)&#10;                    showStartTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showEndTimePicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = parseTime(uiState.endTime),&#10;                onDismiss = { showEndTimePicker = false },&#10;                onTimeSelected = {&#10;                    editWorkViewModel.updateEndTime(it)&#10;                    showEndTimePicker = false&#10;                }&#10;            )&#10;        }&#10;&#10;        if (showStartDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.startDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateStartDay(it)&#10;                    showStartDayPicker = false&#10;                },&#10;                onDismiss = { showStartDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showEndDayPicker) {&#10;            DatePickerModal(&#10;                initialDate = uiState.endDay,&#10;                onDateSelected = {&#10;                    editWorkViewModel.updateEndDay(it)&#10;                    showEndDayPicker = false&#10;                },&#10;                onDismiss = { showEndDayPicker = false }&#10;            )&#10;        }&#10;&#10;        if (showElapsedPicker) {&#10;            MaterialTimePickerDialog(&#10;                initialTime = Pair(uiState.elapsedHour, uiState.elapsedMinute),&#10;                onDismiss = { showElapsedPicker = false },&#10;                onTimeSelected = { timeString -&gt;&#10;                    val (h, m) = timeString.split(&quot;:&quot;).map { it.toIntOrNull() ?: 0 }&#10;                    editWorkViewModel.updateElapsedTime(h, m)&#10;                    showElapsedPicker = false&#10;                },&#10;                showToggleIcon = false&#10;            )&#10;        }&#10;&#10;        if (uiState.showZeroMinutesError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearZeroMinutesError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;1分以上からのみ記録が可能です。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearZeroMinutesError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showStartEndError) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearStartEndError() },&#10;                title = { Text(&quot;エラー&quot;) },&#10;                text = { Text(&quot;開始時刻が終了時刻を超えています。&quot;) },&#10;                properties = DialogProperties(dismissOnClickOutside = false),&#10;                confirmButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearStartEndError() }) {&#10;                        Text(&quot;OK&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        if (uiState.showElapsedTimeOver) {&#10;            AlertDialog(&#10;                onDismissRequest = { editWorkViewModel.clearElapsedTimeOver() },&#10;                title = { Text(&quot;注意&quot;) },&#10;                text = { Text(&quot;活動時間が時間差より大きいです。\nこのまま保存しますか？&quot;) },&#10;                confirmButton = {&#10;                    TextButton(onClick = {&#10;                        editWorkViewModel.clearElapsedTimeOver()&#10;                        editWorkViewModel.saveWork(&#10;                            id = id,&#10;                            isNew = isNew,&#10;                            forceSave = true&#10;                        )&#10;                    }) {&#10;                        Text(&quot;保存&quot;)&#10;                    }&#10;                },&#10;                dismissButton = {&#10;                    TextButton(onClick = { editWorkViewModel.clearElapsedTimeOver() }) {&#10;                        Text(&quot;キャンセル&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun parseTime(time: String): Pair&lt;Int, Int&gt; {&#10;    val parts = time.split(&quot;:&quot;).mapNotNull { it.toIntOrNull() }&#10;    return if (parts.size == 2) Pair(parts[0], parts[1]) else Pair(0, 0)&#10;}&#10;&#10;fun formatMonthDay(fullDate: String): String {&#10;    return try {&#10;        val inputFormat = SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault())&#10;        val outputFormat = SimpleDateFormat(&quot;M/d&quot;, Locale.getDefault())&#10;        val date = inputFormat.parse(fullDate)&#10;        outputFormat.format(date)&#10;    } catch (e: Exception) {&#10;        fullDate&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/log_view/LogViewScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/working_timer/ui/log_view/LogViewScreen.kt" />
              <option name="originalContent" value="package com.example.working_timer.ui.log_view&#10;&#10;import android.content.Intent&#10;import android.view.LayoutInflater&#10;import android.widget.CalendarView&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.CurrencyYen&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.working_timer.ui.components.DateRangePickerModal&#10;import com.example.working_timer.ui.components.FooterNavigationBar&#10;import com.example.working_timer.R&#10;import com.example.working_timer.ui.components.WorkItemComposable&#10;import java.text.NumberFormat&#10;import com.example.working_timer.util.BorderColor&#10;import com.example.working_timer.util.ButtonBackgroundColor&#10;&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogViewScreen(&#10;    viewModel: LogViewViewModel = hiltViewModel(),&#10;    onNavigateToTimer: () -&gt; Unit,&#10;    onNavigateToEditWork: (Int, String, Boolean) -&gt; Unit&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Date formatter for calendar updates&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;&#10;    // Date Range Pickerの表示を制御するState&#10;    var showDateRangePicker by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;&#10;        if (uiState.selectedDay.isNotEmpty()) {&#10;            viewModel.loadWorkList(uiState.selectedDay)&#10;        } else {&#10;            viewModel.init()&#10;        }&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        AndroidView(&#10;            factory = { context -&gt;&#10;                val inflater = LayoutInflater.from(context)&#10;                val view = inflater.inflate(R.layout.calender_view, null)&#10;                val calendarView = view.findViewById&lt;CalendarView&gt;(R.id.calendarView)&#10;                calendarView.setOnDateChangeListener { _, year, month, dayOfMonth -&gt;&#10;                    viewModel.setSelectedDay(year, month, dayOfMonth)&#10;                }&#10;                view&#10;            },&#10;            update = { view -&gt;&#10;                val calendarView = view as CalendarView&#10;                val dateMillis = if (uiState.selectedDay.isNotEmpty()) sdf.parse(uiState.selectedDay)?.time else null&#10;                if (dateMillis != null) {&#10;                    calendarView.date = dateMillis&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        HorizontalDivider(&#10;            color = BorderColor,&#10;            thickness = 1.dp&#10;        )&#10;&#10;        LazyColumn(modifier = Modifier.weight(0.8f)) {&#10;            itemsIndexed(uiState.workList) { index, work -&gt;&#10;                WorkItemComposable(&#10;                    work = work,&#10;                    onDelete = { viewModel.showDeleteDialog(work) },&#10;                    onEdit = {&#10;                        onNavigateToEditWork(&#10;                            work.id,&#10;                            work.start_day,&#10;                            false&#10;                        )&#10;                    }&#10;                )&#10;                if (index &lt; uiState.workList.lastIndex) {&#10;                    HorizontalDivider(&#10;                        color = BorderColor,&#10;                        thickness = 1.dp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.Start&#10;        ) {&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            FloatingActionButton(&#10;                onClick = {&#10;                    onNavigateToEditWork(&#10;                        0,&#10;                        uiState.selectedDay,&#10;                        true&#10;                    )&#10;                },&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.Add,&#10;                    modifier = Modifier&#10;                        .height(24.dp)&#10;                        .width(24.dp),&#10;                    contentDescription = &quot;追加&quot;&#10;                )&#10;            }&#10;            FloatingActionButton(&#10;                onClick = { showDateRangePicker = true },&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.CurrencyYen,&#10;                    contentDescription = &quot;給料計算&quot;&#10;                )&#10;            }&#10;        }&#10;        // 下部ナビゲーションバー&#10;        FooterNavigationBar(&#10;            selectedIndex = 1,&#10;            onTimerClick = onNavigateToTimer,&#10;            onLogClick = {}&#10;        )&#10;    }&#10;&#10;    // 削除ダイアログ&#10;    if (uiState.showDeleteDialog &amp;&amp; uiState.workToDelete != null) {&#10;        AlertDialog(&#10;            onDismissRequest = { viewModel.hideDeleteDialog() },&#10;            title = { Text(&quot;確認&quot;) },&#10;            text = { Text(&quot;本当にこの記録を削除しますか？&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = { viewModel.deleteWork(uiState.workToDelete!!) }) { Text(&quot;はい&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { viewModel.hideDeleteDialog() }) { Text(&quot;いいえ&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    // 集計ダイアログ&#10;    if (uiState.showSumDialog) {&#10;        SumDialog(&#10;            startDate = uiState.sumStartDate,&#10;            endDate = uiState.sumEndDate,&#10;            totalHours = uiState.totalHours,&#10;            totalMinutes = uiState.totalMinutes,&#10;            totalWage = uiState.totalWage,&#10;            calculationMode = uiState.timeCalculationMode,&#10;            onDismiss = { viewModel.hideSumDialog() },&#10;            onWageChange = { viewModel.updateTotalWage(it) },&#10;            onCalculationModeChange = { viewModel.setTimeCalculationMode(it) }&#10;        )&#10;    }&#10;&#10;    // 日付範囲選択ダイアログ&#10;    if (showDateRangePicker) {&#10;        DateRangePickerModal(&#10;            onDateRangeSelected = { pair -&gt;&#10;                val (startDate, endDate) = pair&#10;                if (startDate != null &amp;&amp; endDate != null) {&#10;                    viewModel.showSumDialog(startDate, endDate)&#10;                }&#10;                showDateRangePicker = false&#10;            },&#10;            onDismiss = { showDateRangePicker = false }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SumDialog(&#10;    startDate: Long?,&#10;    endDate: Long?,&#10;    totalHours: Long,&#10;    totalMinutes: Long,&#10;    totalWage: Long,&#10;    calculationMode: TimeCalculationMode,&#10;    onDismiss: () -&gt; Unit,&#10;    onWageChange: (Long) -&gt; Unit,&#10;    onCalculationModeChange: (TimeCalculationMode) -&gt; Unit&#10;) {&#10;    var wage by remember { mutableStateOf(0L) }&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(Unit) {&#10;        wage = 0L&#10;        onWageChange(wage)&#10;    }&#10;&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val formattedStartDate =&#10;        remember(startDate) { if (startDate != null) sdf.format(startDate) else &quot;N/A&quot; }&#10;    val formattedEndDate = remember(endDate) { if (endDate != null) sdf.format(endDate) else &quot;N/A&quot; }&#10;&#10;    val calculationModes = remember {&#10;        TimeCalculationMode.entries.map {&#10;            when (it) {&#10;                TimeCalculationMode.NORMAL -&gt; &quot;通常&quot;&#10;                TimeCalculationMode.ROUND_UP -&gt; &quot;繰り上げ&quot;&#10;                TimeCalculationMode.ROUND_DOWN -&gt; &quot;繰り下げ&quot;&#10;            }&#10;        }&#10;    }&#10;    val selectedModeIndex = calculationMode.ordinal&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;計算結果&quot;) },&#10;        text = {&#10;            Column {&#10;                Text(&#10;                    &quot;期間: ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;合計勤務時間: ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;給料: ${&#10;                        NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)&#10;                    } 円&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                OutlinedTextField(&#10;                    value = if (wage == 0L) &quot;&quot; else wage.toString(),&#10;                    textStyle = TextStyle(&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                    ),&#10;                    onValueChange = {&#10;                        wage = it.toLongOrNull() ?: 0L&#10;                        onWageChange(wage)&#10;                    },&#10;                    label = { Text(&quot;時給&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                SegmentedControl(&#10;                    items = calculationModes,&#10;                    selectedIndex = selectedModeIndex,&#10;                    onSelectionChange = { index -&gt;&#10;                        val mode = TimeCalculationMode.entries[index]&#10;                        onCalculationModeChange(mode)&#10;                        if (index != selectedModeIndex) {&#10;                            onWageChange(wage)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Row {&#10;                TextButton(onClick = {&#10;                    val lines = listOf(&#10;                        &quot;期間 ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                        &quot;時給 ${wage} 円&quot;,&#10;                        &quot;合計 ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                        &quot;給料 ${NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)} 円&quot;&#10;                    )&#10;                    val shareText = lines.joinToString(&quot;\n&quot;)&#10;                    val intent = Intent(Intent.ACTION_SEND).apply {&#10;                        type = &quot;text/plain&quot;&#10;                        putExtra(Intent.EXTRA_TEXT, shareText)&#10;                    }&#10;                    context.startActivity(Intent.createChooser(intent, &quot;共有&quot;))&#10;                }) { Text(&quot;共有&quot;) }&#10;                TextButton(onClick = onDismiss) { Text(&quot;閉じる&quot;) }&#10;            }&#10;&#10;        }&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun SegmentedControl(&#10;    items: List&lt;String&gt;,&#10;    selectedIndex: Int,&#10;    onSelectionChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        shape = RoundedCornerShape(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.LightGray.copy(alpha = 0.3f))&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(4.dp)&#10;        ) {&#10;            items.forEachIndexed { index, item -&gt;&#10;                val isSelected = selectedIndex == index&#10;                Card(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .padding(horizontal = 2.dp),&#10;                    shape = RoundedCornerShape(6.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = if (isSelected) MaterialTheme.colorScheme.primary&#10;                        else Color.Transparent&#10;                    ),&#10;                    onClick = { onSelectionChange(index) }&#10;                ) {&#10;                    Text(&#10;                        text = item,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 8.dp),&#10;                        textAlign = androidx.compose.ui.text.style.TextAlign.Center,&#10;                        color = if (isSelected) Color.White&#10;                        else MaterialTheme.colorScheme.onSurface,&#10;                        fontSize = MaterialTheme.typography.bodySmall.fontSize&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.working_timer.ui.log_view&#10;&#10;import android.content.Intent&#10;import android.view.LayoutInflater&#10;import android.widget.CalendarView&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.CurrencyYen&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.working_timer.ui.components.DateRangePickerModal&#10;import com.example.working_timer.ui.components.FooterNavigationBar&#10;import com.example.working_timer.R&#10;import com.example.working_timer.ui.components.WorkItemComposable&#10;import java.text.NumberFormat&#10;import com.example.working_timer.util.BorderColor&#10;import com.example.working_timer.util.ButtonBackgroundColor&#10;import com.example.working_timer.data.db.Work&#10;&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogViewScreenHolder(&#10;    viewModel: LogViewViewModel = hiltViewModel(),&#10;    onNavigateToTimer: () -&gt; Unit,&#10;    onNavigateToEditWork: (Int, String, Boolean) -&gt; Unit&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Date Range Pickerの表示を制御するState&#10;    var showDateRangePicker by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        if (uiState.selectedDay.isNotEmpty()) {&#10;            viewModel.loadWorkList(uiState.selectedDay)&#10;        } else {&#10;            viewModel.init()&#10;        }&#10;    }&#10;&#10;    LogViewScreen(&#10;        uiState = uiState,&#10;        showDateRangePicker = showDateRangePicker,&#10;        onNavigateToTimer = onNavigateToTimer,&#10;        onNavigateToEditWork = onNavigateToEditWork,&#10;        onDateSelected = { year, month, dayOfMonth -&gt;&#10;            viewModel.setSelectedDay(year, month, dayOfMonth)&#10;        },&#10;        onShowDeleteDialog = { work -&gt;&#10;            viewModel.showDeleteDialog(work)&#10;        },&#10;        onHideDeleteDialog = {&#10;            viewModel.hideDeleteDialog()&#10;        },&#10;        onDeleteWork = { work -&gt;&#10;            viewModel.deleteWork(work)&#10;        },&#10;        onShowDateRangePicker = {&#10;            showDateRangePicker = true&#10;        },&#10;        onHideDateRangePicker = {&#10;            showDateRangePicker = false&#10;        },&#10;        onDateRangeSelected = { startDate, endDate -&gt;&#10;            if (startDate != null &amp;&amp; endDate != null) {&#10;                viewModel.showSumDialog(startDate, endDate)&#10;            }&#10;            showDateRangePicker = false&#10;        },&#10;        onHideSumDialog = {&#10;            viewModel.hideSumDialog()&#10;        },&#10;        onUpdateTotalWage = { wage -&gt;&#10;            viewModel.updateTotalWage(wage)&#10;        },&#10;        onSetTimeCalculationMode = { mode -&gt;&#10;            viewModel.setTimeCalculationMode(mode)&#10;        }&#10;    )&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LogViewScreen(&#10;    uiState: LogViewUiState,&#10;    showDateRangePicker: Boolean,&#10;    onNavigateToTimer: () -&gt; Unit,&#10;    onNavigateToEditWork: (Int, String, Boolean) -&gt; Unit,&#10;    onDateSelected: (Int, Int, Int) -&gt; Unit,&#10;    onShowDeleteDialog: (Work) -&gt; Unit,&#10;    onHideDeleteDialog: () -&gt; Unit,&#10;    onDeleteWork: (Work) -&gt; Unit,&#10;    onShowDateRangePicker: () -&gt; Unit,&#10;    onHideDateRangePicker: () -&gt; Unit,&#10;    onDateRangeSelected: (Long?, Long?) -&gt; Unit,&#10;    onHideSumDialog: () -&gt; Unit,&#10;    onUpdateTotalWage: (Long) -&gt; Unit,&#10;    onSetTimeCalculationMode: (TimeCalculationMode) -&gt; Unit&#10;) {&#10;    // Date formatter for calendar updates&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        AndroidView(&#10;            factory = { context -&gt;&#10;                val inflater = LayoutInflater.from(context)&#10;                val view = inflater.inflate(R.layout.calender_view, null)&#10;                val calendarView = view.findViewById&lt;CalendarView&gt;(R.id.calendarView)&#10;                calendarView.setOnDateChangeListener { _, year, month, dayOfMonth -&gt;&#10;                    onDateSelected(year, month, dayOfMonth)&#10;                }&#10;                view&#10;            },&#10;            update = { view -&gt;&#10;                val calendarView = view as CalendarView&#10;                val dateMillis = if (uiState.selectedDay.isNotEmpty()) sdf.parse(uiState.selectedDay)?.time else null&#10;                if (dateMillis != null) {&#10;                    calendarView.date = dateMillis&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        HorizontalDivider(&#10;            color = BorderColor,&#10;            thickness = 1.dp&#10;        )&#10;&#10;        LazyColumn(modifier = Modifier.weight(0.8f)) {&#10;            itemsIndexed(uiState.workList) { index, work -&gt;&#10;                WorkItemComposable(&#10;                    work = work,&#10;                    onDelete = { onShowDeleteDialog(work) },&#10;                    onEdit = {&#10;                        onNavigateToEditWork(&#10;                            work.id,&#10;                            work.start_day,&#10;                            false&#10;                        )&#10;                    }&#10;                )&#10;                if (index &lt; uiState.workList.lastIndex) {&#10;                    HorizontalDivider(&#10;                        color = BorderColor,&#10;                        thickness = 1.dp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.Start&#10;        ) {&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            FloatingActionButton(&#10;                onClick = {&#10;                    onNavigateToEditWork(&#10;                        0,&#10;                        uiState.selectedDay,&#10;                        true&#10;                    )&#10;                },&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.Add,&#10;                    modifier = Modifier&#10;                        .height(24.dp)&#10;                        .width(24.dp),&#10;                    contentDescription = &quot;追加&quot;&#10;                )&#10;            }&#10;            FloatingActionButton(&#10;                onClick = onShowDateRangePicker,&#10;                modifier = Modifier.padding(horizontal = 8.dp, vertical = 16.dp),&#10;                containerColor = ButtonBackgroundColor,&#10;                contentColor = Color.White,&#10;                shape = RoundedCornerShape(24.dp),&#10;            ) {&#10;                Icon(&#10;                    imageVector = androidx.compose.material.icons.Icons.Filled.CurrencyYen,&#10;                    contentDescription = &quot;給料計算&quot;&#10;                )&#10;            }&#10;        }&#10;        // 下部ナビゲーションバー&#10;        FooterNavigationBar(&#10;            selectedIndex = 1,&#10;            onTimerClick = onNavigateToTimer,&#10;            onLogClick = {}&#10;        )&#10;    }&#10;&#10;    // 削除ダイアログ&#10;    if (uiState.showDeleteDialog &amp;&amp; uiState.workToDelete != null) {&#10;        AlertDialog(&#10;            onDismissRequest = onHideDeleteDialog,&#10;            title = { Text(&quot;確認&quot;) },&#10;            text = { Text(&quot;本当にこの記録を削除しますか？&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = { onDeleteWork(uiState.workToDelete) }) { Text(&quot;はい&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = onHideDeleteDialog) { Text(&quot;いいえ&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    // 集計ダイアログ&#10;    if (uiState.showSumDialog) {&#10;        SumDialog(&#10;            startDate = uiState.sumStartDate,&#10;            endDate = uiState.sumEndDate,&#10;            totalHours = uiState.totalHours,&#10;            totalMinutes = uiState.totalMinutes,&#10;            totalWage = uiState.totalWage,&#10;            calculationMode = uiState.timeCalculationMode,&#10;            onDismiss = onHideSumDialog,&#10;            onWageChange = onUpdateTotalWage,&#10;            onCalculationModeChange = onSetTimeCalculationMode&#10;        )&#10;    }&#10;&#10;    // 日付範囲選択ダイアログ&#10;    if (showDateRangePicker) {&#10;        DateRangePickerModal(&#10;            onDateRangeSelected = { pair -&gt;&#10;                val (startDate, endDate) = pair&#10;                onDateRangeSelected(startDate, endDate)&#10;            },&#10;            onDismiss = onHideDateRangePicker&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SumDialog(&#10;    startDate: Long?,&#10;    endDate: Long?,&#10;    totalHours: Long,&#10;    totalMinutes: Long,&#10;    totalWage: Long,&#10;    calculationMode: TimeCalculationMode,&#10;    onDismiss: () -&gt; Unit,&#10;    onWageChange: (Long) -&gt; Unit,&#10;    onCalculationModeChange: (TimeCalculationMode) -&gt; Unit&#10;) {&#10;    var wage by remember { mutableStateOf(0L) }&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(Unit) {&#10;        wage = 0L&#10;        onWageChange(wage)&#10;    }&#10;&#10;    val sdf = remember { SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault()) }&#10;    val formattedStartDate =&#10;        remember(startDate) { if (startDate != null) sdf.format(startDate) else &quot;N/A&quot; }&#10;    val formattedEndDate = remember(endDate) { if (endDate != null) sdf.format(endDate) else &quot;N/A&quot; }&#10;&#10;    val calculationModes = remember {&#10;        TimeCalculationMode.entries.map {&#10;            when (it) {&#10;                TimeCalculationMode.NORMAL -&gt; &quot;通常&quot;&#10;                TimeCalculationMode.ROUND_UP -&gt; &quot;繰り上げ&quot;&#10;                TimeCalculationMode.ROUND_DOWN -&gt; &quot;繰り下げ&quot;&#10;            }&#10;        }&#10;    }&#10;    val selectedModeIndex = calculationMode.ordinal&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;計算結果&quot;) },&#10;        text = {&#10;            Column {&#10;                Text(&#10;                    &quot;期間: ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;合計勤務時間: ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    &quot;給料: ${&#10;                        NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)&#10;                    } 円&quot;,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                OutlinedTextField(&#10;                    value = if (wage == 0L) &quot;&quot; else wage.toString(),&#10;                    textStyle = TextStyle(&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        fontSize = MaterialTheme.typography.titleMedium.fontSize&#10;                    ),&#10;                    onValueChange = {&#10;                        wage = it.toLongOrNull() ?: 0L&#10;                        onWageChange(wage)&#10;                    },&#10;                    label = { Text(&quot;時給&quot;) },&#10;                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                SegmentedControl(&#10;                    items = calculationModes,&#10;                    selectedIndex = selectedModeIndex,&#10;                    onSelectionChange = { index -&gt;&#10;                        val mode = TimeCalculationMode.entries[index]&#10;                        onCalculationModeChange(mode)&#10;                        if (index != selectedModeIndex) {&#10;                            onWageChange(wage)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        },&#10;        confirmButton = {&#10;            Row {&#10;                TextButton(onClick = {&#10;                    val lines = listOf(&#10;                        &quot;期間 ${formattedStartDate} ~ ${formattedEndDate}&quot;,&#10;                        &quot;時給 ${wage} 円&quot;,&#10;                        &quot;合計 ${totalHours}時間 ${totalMinutes}分&quot;,&#10;                        &quot;給料 ${NumberFormat.getNumberInstance(Locale.JAPAN).format(totalWage)} 円&quot;&#10;                    )&#10;                    val shareText = lines.joinToString(&quot;\n&quot;)&#10;                    val intent = Intent(Intent.ACTION_SEND).apply {&#10;                        type = &quot;text/plain&quot;&#10;                        putExtra(Intent.EXTRA_TEXT, shareText)&#10;                    }&#10;                    context.startActivity(Intent.createChooser(intent, &quot;共有&quot;))&#10;                }) { Text(&quot;共有&quot;) }&#10;                TextButton(onClick = onDismiss) { Text(&quot;閉じる&quot;) }&#10;            }&#10;&#10;        }&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;fun SegmentedControl(&#10;    items: List&lt;String&gt;,&#10;    selectedIndex: Int,&#10;    onSelectionChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        shape = RoundedCornerShape(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color.LightGray.copy(alpha = 0.3f))&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(4.dp)&#10;        ) {&#10;            items.forEachIndexed { index, item -&gt;&#10;                val isSelected = selectedIndex == index&#10;                Card(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .padding(horizontal = 2.dp),&#10;                    shape = RoundedCornerShape(6.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = if (isSelected) MaterialTheme.colorScheme.primary&#10;                        else Color.Transparent&#10;                    ),&#10;                    onClick = { onSelectionChange(index) }&#10;                ) {&#10;                    Text(&#10;                        text = item,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(vertical = 8.dp),&#10;                        textAlign = androidx.compose.ui.text.style.TextAlign.Center,&#10;                        color = if (isSelected) Color.White&#10;                        else MaterialTheme.colorScheme.onSurface,&#10;                        fontSize = MaterialTheme.typography.bodySmall.fontSize&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>